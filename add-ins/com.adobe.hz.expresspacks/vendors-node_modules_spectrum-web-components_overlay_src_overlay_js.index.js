(self["webpackChunkpack_add_on"] = self["webpackChunkpack_add_on"] || []).push([["vendors-node_modules_spectrum-web-components_overlay_src_overlay_js"],{

/***/ "./node_modules/@floating-ui/core/dist/floating-ui.core.esm.development.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.esm.development.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrow": () => (/* binding */ arrow),
/* harmony export */   "autoPlacement": () => (/* binding */ autoPlacement),
/* harmony export */   "computePosition": () => (/* binding */ computePosition),
/* harmony export */   "detectOverflow": () => (/* binding */ detectOverflow),
/* harmony export */   "flip": () => (/* binding */ flip),
/* harmony export */   "hide": () => (/* binding */ hide),
/* harmony export */   "inline": () => (/* binding */ inline),
/* harmony export */   "limitShift": () => (/* binding */ limitShift),
/* harmony export */   "offset": () => (/* binding */ offset),
/* harmony export */   "rectToClientRect": () => (/* binding */ rectToClientRect),
/* harmony export */   "shift": () => (/* binding */ shift),
/* harmony export */   "size": () => (/* binding */ size)
/* harmony export */ });
function getSide(placement) {
  return placement.split('-')[0];
}

function getAlignment(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}

function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === 'x';
  let coords;

  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;

    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;

    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }

  switch (getAlignment(placement)) {
    case 'start':
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;

    case 'end':
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }

  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */

const computePosition = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));

  {
    if (platform == null) {
      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));
    }

    if (middleware.filter(_ref => {
      let {
        name
      } = _ref;
      return name === 'autoPlacement' || name === 'flip';
    }).length > 1) {
      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));
    }
  }

  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let _debug_loop_count_ = 0;

  for (let i = 0; i < middleware.length; i++) {
    {
      _debug_loop_count_++;

      if (_debug_loop_count_ > 100) {
        throw new Error(['Floating UI: The middleware lifecycle appears to be', 'running in an infinite loop. This is usually caused by a `reset`', 'continually being returned without a break condition.'].join(' '));
      }
    }

    const {
      name,
      fn
    } = middleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = { ...middlewareData,
      [name]: { ...middlewareData[name],
        ...data
      }
    };

    if (reset) {
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }

        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }

        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }

      i = -1;
      continue;
    }
  }

  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}

function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}

function rectToClientRect(rect) {
  return { ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;

  if (options === void 0) {
    options = {};
  }

  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === 'floating' ? { ...rects.floating,
      x,
      y
    } : rects.reference,
    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]); // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}

const min = Math.min;
const max = Math.max;

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}

/**
 * Positions an inner element of the floating element such that it is centered
 * to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = options => ({
  name: 'arrow',
  options,

  async fn(middlewareArguments) {
    // Since `element` is required, we don't Partial<> the type
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x,
      y,
      placement,
      rects,
      platform
    } = middlewareArguments;

    if (element == null) {
      {
        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');
      }

      return {};
    }

    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const minProp = axis === 'y' ? 'top' : 'left';
    const maxProp = axis === 'y' ? 'bottom' : 'right';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    const clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside of the floating element's bounds

    const min = paddingObject[minProp];
    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = within(min, center, max);
    return {
      data: {
        [axis]: offset,
        centerOffset: center - offset
      }
    };
  }

});

const hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);
}

function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }

  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';

  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }

  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}

const hash = {
  start: 'end',
  end: 'start'
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, matched => hash[matched]);
}

const sides = ['top', 'right', 'bottom', 'left'];
const allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);

function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter(placement => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }

    return true;
  });
}

/**
 * Automatically chooses the `placement` which has the most space available.
 * @see https://floating-ui.com/docs/autoPlacement
 */
const autoPlacement = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'autoPlacement',
    options,

    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;

      const {
        x,
        y,
        rects,
        middlewareData,
        placement,
        platform,
        elements
      } = middlewareArguments;
      const {
        alignment = null,
        allowedPlacements = allPlacements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = options;
      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;
      const currentPlacement = placements[currentIndex];

      if (currentPlacement == null) {
        return {};
      }

      const {
        main,
        cross
      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place

      if (placement !== currentPlacement) {
        return {
          x,
          y,
          reset: {
            placement: placements[0]
          }
        };
      }

      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];
      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check

      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }

      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {
        let {
          overflows
        } = _ref;
        return overflows.every(overflow => overflow <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;

      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }

      return {};
    }

  };
};

function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}

/**
 * Changes the placement of the floating element to one that will fit if the
 * initially specified `placement` does not.
 * @see https://floating-ui.com/docs/flip
 */
const flip = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'flip',
    options,

    async fn(middlewareArguments) {
      var _middlewareData$flip;

      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];

      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }

      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }

      overflowsData = [...overflowsData, {
        placement,
        overflows
      }]; // One or more sides is overflowing

      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;

        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];

        if (nextPlacement) {
          // Try next placement and re-run the lifecycle
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        let resetPlacement = 'bottom';

        switch (fallbackStrategy) {
          case 'bestFit':
            {
              var _overflowsData$map$so;

              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;

              if (placement) {
                resetPlacement = placement;
              }

              break;
            }

          case 'initialPlacement':
            resetPlacement = initialPlacement;
            break;
        }

        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }

      return {};
    }

  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}

function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0);
}

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = function (_temp) {
  let {
    strategy = 'referenceHidden',
    ...detectOverflowOptions
  } = _temp === void 0 ? {} : _temp;
  return {
    name: 'hide',

    async fn(middlewareArguments) {
      const {
        rects
      } = middlewareArguments;

      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }

        case 'escaped':
          {
            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }

        default:
          {
            return {};
          }
      }
    }

  };
};

function convertValueToCoords(placement, rects, value, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }

  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === 'x';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === 'function' ? value({ ...rects,
    placement
  }) : value; // eslint-disable-next-line prefer-const

  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };

  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }

  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
/**
 * Displaces the floating element from its reference element.
 * @see https://floating-ui.com/docs/offset
 */

const offset = function (value) {
  if (value === void 0) {
    value = 0;
  }

  return {
    name: 'offset',
    options: value,

    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement,
        rects,
        platform,
        elements
      } = middlewareArguments;
      const diffCoords = convertValueToCoords(placement, rects, value, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }

  };
};

function getCrossAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/**
 * Shifts the floating element in order to keep it in view when it will overflow
 * a clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'shift',
    options,

    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];

      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min, mainAxisCoord, max);
      }

      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min, crossAxisCoord, max);
      }

      const limitedCoords = limiter.fn({ ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return { ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }

  };
};

/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */
const limitShift = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    options,

    fn(middlewareArguments) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = middlewareArguments;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = options;
      const coords = {
        x,
        y
      };
      const mainAxis = getMainAxisFromPlacement(placement);
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = typeof offset === 'function' ? offset({ ...rects,
        placement
      }) : offset;
      const computedOffset = typeof rawOffset === 'number' ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };

      if (checkMainAxis) {
        const len = mainAxis === 'y' ? 'height' : 'width';
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;

        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }

      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;

        const len = mainAxis === 'y' ? 'width' : 'height';
        const isOriginSide = ['top', 'left'].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);

        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }

      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }

  };
};

/**
 * Provides data to change the size of the floating element. For instance,
 * prevent it from overflowing its clipping boundary or match the width of the
 * reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'size',
    options,

    async fn(middlewareArguments) {
      const {
        placement,
        rects,
        platform,
        elements
      } = middlewareArguments;
      const {
        apply,
        ...detectOverflowOptions
      } = options;
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      let heightSide;
      let widthSide;

      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }

      const xMin = max(overflow.left, 0);
      const xMax = max(overflow.right, 0);
      const yMin = max(overflow.top, 0);
      const yMax = max(overflow.bottom, 0);
      const dimensions = {
        height: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),
        width: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])
      };
      const prevDimensions = await platform.getDimensions(elements.floating);
      apply == null ? void 0 : apply({ ...dimensions,
        ...rects
      });
      const nextDimensions = await platform.getDimensions(elements.floating);

      if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }

      return {};
    }

  };
};

/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */
const inline = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'inline',
    options,

    async fn(middlewareArguments) {
      var _await$platform$getCl;

      const {
        placement,
        elements,
        rects,
        platform,
        strategy
      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
      // ClientRect's bounds, despite the event listener being triggered. A
      // padding of 2 seems to handle this issue.

      const {
        padding = 2,
        x,
        y
      } = options;
      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: rects.reference,
        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
        strategy
      }) : rects.reference);
      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];
      const paddingObject = getSideObjectFromPadding(padding);

      function getBoundingClientRect() {
        // There are two rects and they are disjoined
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          var _clientRects$find;

          // Find the first rect in which the point is fully inside
          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;
        } // There are 2 or more connected rects


        if (clientRects.length >= 2) {
          if (getMainAxisFromPlacement(placement) === 'x') {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide(placement) === 'top';
            const top = firstRect.top;
            const bottom = lastRect.bottom;
            const left = isTop ? firstRect.left : lastRect.left;
            const right = isTop ? firstRect.right : lastRect.right;
            const width = right - left;
            const height = bottom - top;
            return {
              top,
              bottom,
              left,
              right,
              width,
              height,
              x: left,
              y: top
            };
          }

          const isLeftSide = getSide(placement) === 'left';
          const maxRight = max(...clientRects.map(rect => rect.right));
          const minLeft = min(...clientRects.map(rect => rect.left));
          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }

        return fallback;
      }

      const resetRects = await platform.getElementRects({
        reference: {
          getBoundingClientRect
        },
        floating: elements.floating,
        strategy
      });

      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }

      return {};
    }

  };
};




/***/ }),

/***/ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.development.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.development.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrow": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow),
/* harmony export */   "autoPlacement": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),
/* harmony export */   "autoUpdate": () => (/* binding */ autoUpdate),
/* harmony export */   "computePosition": () => (/* binding */ computePosition),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),
/* harmony export */   "flip": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip),
/* harmony export */   "getOverflowAncestors": () => (/* binding */ getOverflowAncestors),
/* harmony export */   "hide": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide),
/* harmony export */   "inline": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline),
/* harmony export */   "limitShift": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift),
/* harmony export */   "offset": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),
/* harmony export */   "shift": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift),
/* harmony export */   "size": () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size)
/* harmony export */ });
/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ "./node_modules/@floating-ui/core/dist/floating-ui.core.esm.development.js");



function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function getNodeName(node) {
  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';
}

function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isContainingBlock(element) {
  // TODO: Try and use feature detection here instead
  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');
  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that
  // create a containing block.
  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

  return css.transform !== 'none' || css.perspective !== 'none' || // @ts-ignore (TS 4.1 compat)
  css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);
}
function isLayoutViewport() {
  // Not Safari
  return !/^((?!chrome|android).)*safari/i.test(navigator.userAgent); // Feature detection for this fails in various ways
  // • Always-visible scrollbar or not
  // • Width of <html>, etc.
  // const vV = win.visualViewport;
  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;
}

const min = Math.min;
const max = Math.max;
const round = Math.round;

function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;

  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;

  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  const win = isElement(element) ? getWindow(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}

function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)
  isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || ( // DOM Element detected
    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement(node) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
}

function getContainingBlock(element) {
  let currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  const window = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getDimensions(element) {
  if (isHTMLElement(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }

  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);

  if (offsetParent === documentElement) {
    return rect;
  }

  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } // This doesn't appear to be need to be negated.
    // else if (documentElement) {
    //   offsets.x = getWindowScrollBarX(documentElement);
    // }

  }

  return { ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width,
    height,
    x,
    y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;

  if (getComputedStyle$1(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width,
    height,
    x,
    y
  };
}

function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);

  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {
    // @ts-ignore assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }

  return getNearestOverflowAncestor(parentNode);
}

function getOverflowAncestors(node, list) {
  var _node$ownerDocument;

  if (list === void 0) {
    list = [];
  }

  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here
  updatedList.concat(getOverflowAncestors(target));
}

function contains(parent, child) {
  const rootNode = child == null ? void 0 : child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method

  if (parent != null && parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;

    do {
      // use `===` replace node.isSameNode()
      if (next && parent === next) {
        return true;
      } // @ts-ignore: need a better way to handle this...


      next = next.parentNode || next.host;
    } while (next);
  }

  return false;
}

function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}

function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === 'viewport') {
    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getViewportRect(element, strategy));
  }

  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }

  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getDocumentRect(getDocumentElement(element)));
} // A "clipping ancestor" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // @ts-ignore isElement check ensures we return Array<Element>


  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');
} // Gets the maximum area that the element is visible in due to any number of
// clipping ancestors


function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: _ref => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: { ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  getClientRects: element => Array.from(element.getClientRects()),
  isRTL: element => getComputedStyle$1(element).direction === 'rtl'
};

/**
 * Automatically updates the position of the floating element when necessary.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }

  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize: _ancestorResize = true,
    elementResize: _elementResize = true,
    animationFrame = false
  } = options;
  let cleanedUp = false;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestorResize = _ancestorResize && !animationFrame;
  const elementResize = _elementResize && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  let observer = null;

  if (elementResize) {
    observer = new ResizeObserver(update);
    isElement(reference) && observer.observe(reference);
    observer.observe(floating);
  }

  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;

  if (animationFrame) {
    frameLoop();
  }

  function frameLoop() {
    if (cleanedUp) {
      return;
    }

    const nextRefRect = getBoundingClientRect(reference);

    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }

    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }

  return () => {
    var _observer;

    cleanedUp = true;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;

    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */

const computePosition = (reference, floating, options) => (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {
  platform,
  ...options
});




/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/active-overlay.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/active-overlay.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_ActiveOverlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/ActiveOverlay.js */ "./node_modules/@spectrum-web-components/overlay/src/ActiveOverlay.js");
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

customElements.define('active-overlay', _src_ActiveOverlay_js__WEBPACK_IMPORTED_MODULE_0__.ActiveOverlay);
//# sourceMappingURL=active-overlay.js.map

/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/ActiveOverlay.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/ActiveOverlay.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveOverlay": () => (/* binding */ ActiveOverlay)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/base */ "./node_modules/@spectrum-web-components/base/src/Base.js");
/* harmony import */ var _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @spectrum-web-components/base */ "./node_modules/lit/index.js");
/* harmony import */ var _spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @spectrum-web-components/base/src/directives.js */ "./node_modules/lit/directives/if-defined.js");
/* harmony import */ var _spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @spectrum-web-components/base/src/decorators.js */ "./node_modules/lit/decorators.js");
/* harmony import */ var _spectrum_web_components_shared_src_reparent_children_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @spectrum-web-components/shared/src/reparent-children.js */ "./node_modules/@spectrum-web-components/shared/src/reparent-children.js");
/* harmony import */ var _spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @spectrum-web-components/shared/src/first-focusable-in.js */ "./node_modules/@spectrum-web-components/shared/src/first-focusable-in.js");
/* harmony import */ var _active_overlay_css_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./active-overlay.css.js */ "./node_modules/@spectrum-web-components/overlay/src/active-overlay.css.js");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/core/dist/floating-ui.core.esm.development.js");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.development.js");
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/








const stateMachine = {
    initial: 'idle',
    states: {
        idle: {
            on: {
                active: 'active',
            },
        },
        active: {
            on: {
                hiding: 'hiding',
                idle: 'idle',
            },
        },
        hiding: {
            on: {
                dispose: 'dispose',
            },
        },
        dispose: {
            on: {
                disposed: 'disposed',
            },
        },
        disposed: {
            on: {},
        },
    },
};
const stateTransition = (state, event) => {
    if (!state)
        return stateMachine.initial;
    /* c8 ignore next */
    if (!event)
        return state;
    return stateMachine.states[state].on[event] || state;
};
const parentOverlayOf = (el) => {
    const closestOverlay = el.closest('active-overlay');
    if (closestOverlay) {
        return closestOverlay;
    }
    const rootNode = el.getRootNode();
    if (rootNode.host) {
        return parentOverlayOf(rootNode.host);
    }
    return null;
};
/**
 * @element active-overlay
 *
 * @slot - content to display in the overlay
 */
class ActiveOverlay extends _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.SpectrumElement {
    constructor() {
        super();
        this._state = stateTransition();
        this.animating = false;
        this.theme = {};
        this.tabbingAway = false;
        this.offset = 6;
        this.skidding = 0;
        this.interaction = 'hover';
        this.positionAnimationFrame = 0;
        this.willNotifyClosed = false;
        this.isConstrained = false;
        this.updateOverlayPosition = async () => {
            if (!this.placement || this.placement === 'none') {
                return;
            }
            await (document.fonts ? document.fonts.ready : Promise.resolve());
            function roundByDPR(num) {
                const dpr = window.devicePixelRatio || 1;
                return Math.round(num * dpr) / dpr || -10000;
            }
            // See: https://spectrum.adobe.com/page/popover/#Container-padding
            const REQUIRED_DISTANCE_TO_EDGE = 8;
            // See: https://github.com/adobe/spectrum-web-components/issues/910
            const MIN_OVERLAY_HEIGHT = 100;
            const middleware = [
                (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.offset)({
                    mainAxis: this.offset,
                    crossAxis: this.skidding,
                }),
                (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.flip)({
                    fallbackStrategy: 'initialPlacement',
                }),
                (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.shift)({ padding: REQUIRED_DISTANCE_TO_EDGE }),
                (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.size)({
                    padding: REQUIRED_DISTANCE_TO_EDGE,
                    apply: ({ width, height, floating }) => {
                        const maxHeight = Math.max(MIN_OVERLAY_HEIGHT, Math.floor(height));
                        const actualHeight = floating.height;
                        this.initialHeight = !this.isConstrained
                            ? actualHeight
                            : this.initialHeight || actualHeight;
                        this.isConstrained =
                            actualHeight < this.initialHeight ||
                                maxHeight <= actualHeight;
                        const appliedHeight = this.isConstrained
                            ? `${maxHeight}px`
                            : '';
                        Object.assign(this.style, {
                            maxWidth: `${Math.floor(width)}px`,
                            maxHeight: appliedHeight,
                            height: appliedHeight,
                        });
                    },
                }),
            ];
            if (this.overlayContentTip) {
                middleware.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.arrow)({ element: this.overlayContentTip }));
            }
            const { x, y, placement, middlewareData } = await (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.computePosition)(this.virtualTrigger || this.trigger, this, {
                placement: this.placement,
                middleware,
            });
            Object.assign(this.style, {
                top: '0px',
                left: '0px',
                transform: `translate(${roundByDPR(x)}px, ${roundByDPR(y)}px)`,
            });
            if (placement !== this.getAttribute('actual-placement')) {
                this.setAttribute('actual-placement', placement);
                this.overlayContent.setAttribute('placement', placement);
            }
            if (this.overlayContentTip && middlewareData.arrow) {
                const { x: arrowX, y: arrowY } = middlewareData.arrow;
                Object.assign(this.overlayContentTip.style, {
                    left: arrowX != null ? `${roundByDPR(arrowX)}px` : '',
                    top: arrowY != null ? `${roundByDPR(arrowY)}px` : '',
                    right: '',
                    bottom: '',
                });
            }
        };
        this.handleInlineTriggerKeydown = (event) => {
            const { code, shiftKey } = event;
            /* c8 ignore next */
            if (code !== 'Tab')
                return;
            if (shiftKey) {
                this.tabbingAway = true;
                this.dispatchEvent(new Event('close'));
                return;
            }
            event.stopPropagation();
            event.preventDefault();
            this.focus();
        };
        this.stealOverlayContentPromise = Promise.resolve();
        this.stealOverlayContentPromise = new Promise((res) => (this.stealOverlayContentResolver = res));
    }
    get state() {
        return this._state;
    }
    set state(state) {
        const nextState = stateTransition(this.state, state);
        if (nextState === this.state) {
            return;
        }
        this._state = nextState;
        if (this.state === 'active' || this.state === 'hiding') {
            this.setAttribute('state', this.state);
        }
        else {
            this.removeAttribute('state');
        }
    }
    async focus() {
        const firstFocusable = (0,_spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_3__.firstFocusableIn)(this);
        if (firstFocusable) {
            if (firstFocusable.updateComplete) {
                await firstFocusable.updateComplete;
            }
            const activeElement = this.getRootNode()
                .activeElement;
            if (activeElement === this || !this.contains(activeElement)) {
                firstFocusable.focus();
            }
            /* c8 ignore next 3 */
        }
        else {
            super.focus();
        }
        this.removeAttribute('tabindex');
    }
    get hasTheme() {
        return !!this.theme.color || !!this.theme.scale || !!this.theme.lang;
    }
    static get styles() {
        return [_active_overlay_css_js__WEBPACK_IMPORTED_MODULE_4__["default"]];
    }
    get hasModalRoot() {
        return !!this._modalRoot;
    }
    feature() {
        this.tabIndex = -1;
        const parentOverlay = parentOverlayOf(this.trigger);
        const parentIsModal = parentOverlay && parentOverlay.slot === 'open';
        if (parentIsModal) {
            this._modalRoot = parentOverlay._modalRoot || parentOverlay;
        }
        // If an overlay it triggered from within a "modal" overlay, it needs to continue
        // to act like one to get treated correctly in regards to tab trapping.
        if (this.interaction === 'modal' || this._modalRoot) {
            this.slot = 'open';
            if (this.interaction === 'modal') {
                this.setAttribute('aria-modal', 'true');
            }
            // If this isn't a modal root, walk up the overlays to the next modal root
            // and "feature" each on of the intervening overlays.
            if (this._modalRoot) {
                parentOverlay === null || parentOverlay === void 0 ? void 0 : parentOverlay.feature();
            }
        }
    }
    obscure(nextOverlayInteraction) {
        if (this.slot && nextOverlayInteraction === 'modal') {
            this.removeAttribute('slot');
            this.removeAttribute('aria-modal');
            // Obscure upto and including the next modal root.
            if (this.interaction !== 'modal') {
                const parentOverlay = parentOverlayOf(this.trigger);
                this._modalRoot = parentOverlay === null || parentOverlay === void 0 ? void 0 : parentOverlay.obscure(nextOverlayInteraction);
                return this._modalRoot;
            }
            return this;
        }
        return undefined;
    }
    async firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        /* c8 ignore next */
        if (!this.overlayContent || !this.trigger)
            return;
        this.stealOverlayContent(this.overlayContent);
        this.state = 'active';
        this.feature();
        if (this.placement === 'none') {
            this.style.setProperty('--swc-visual-viewport-height', `${window.innerHeight}px`);
        }
        else if (this.placement) {
            await this.updateOverlayPosition();
            document.addEventListener('sp-update-overlays', this.updateOverlayPosition);
            window.addEventListener('scroll', this.updateOverlayPosition);
        }
        const actions = [];
        if (this.placement && this.placement !== 'none') {
            actions.push(this.applyContentAnimation('sp-overlay-fade-in'));
        }
        if (typeof this.overlayContent.updateComplete !==
            'undefined') {
            actions.push(this.overlayContent.updateComplete);
        }
        this.childrenReady = Promise.all(actions);
    }
    async openCallback(lifecycleCallback) {
        await this.updateComplete;
        if (this.receivesFocus) {
            await this.focus();
        }
        await lifecycleCallback();
        this.trigger.dispatchEvent(new CustomEvent('sp-opened', {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: {
                interaction: this.interaction,
            },
        }));
    }
    open(openDetail) {
        this.extractDetail(openDetail);
    }
    extractDetail(detail) {
        this.overlayContent = detail.content;
        this.overlayContentTip = detail.contentTip;
        this.trigger = detail.trigger;
        this.virtualTrigger = detail.virtualTrigger;
        this.placement = detail.placement;
        this.offset = detail.offset;
        this.skidding = detail.skidding || 0;
        this.interaction = detail.interaction;
        this.theme = detail.theme;
        this.receivesFocus = detail.receivesFocus;
    }
    dispose() {
        /* c8 ignore next */
        if (this.state !== 'dispose')
            return;
        /* c8 ignore next 4 */
        if (this.timeout) {
            clearTimeout(this.timeout);
            delete this.timeout;
        }
        this.trigger.removeEventListener('keydown', this.handleInlineTriggerKeydown);
        this.returnOverlayContent();
        this.state = 'disposed';
        if (this.willNotifyClosed) {
            this.overlayContent.dispatchEvent(new Event('sp-overlay-closed'));
            this.willNotifyClosed = false;
        }
    }
    stealOverlayContent(element) {
        this.originalPlacement = element.getAttribute('placement');
        this.restoreContent = (0,_spectrum_web_components_shared_src_reparent_children_js__WEBPACK_IMPORTED_MODULE_5__.reparentChildren)([element], this, {
            position: 'beforeend',
            prepareCallback: (el) => {
                const slotName = el.slot;
                const placement = el.placement;
                el.removeAttribute('slot');
                return (el) => {
                    el.slot = slotName;
                    el.placement = placement;
                };
            },
        });
        this.stealOverlayContentResolver();
    }
    returnOverlayContent() {
        /* c8 ignore next */
        if (!this.restoreContent)
            return;
        const [element] = this.restoreContent();
        this.restoreContent = undefined;
        this.willNotifyClosed = true;
        if (this.originalPlacement) {
            element.setAttribute('placement', this.originalPlacement);
            delete this.originalPlacement;
        }
    }
    async hide(animated = true) {
        this.state = 'hiding';
        if (animated) {
            await this.applyContentAnimation('sp-overlay-fade-out');
        }
        this.state = 'dispose';
    }
    schedulePositionUpdate() {
        // Edge needs a little time to update the DOM before computing the layout
        cancelAnimationFrame(this.positionAnimationFrame);
        this.positionAnimationFrame = requestAnimationFrame(() => this.updateOverlayPosition());
    }
    onSlotChange() {
        this.schedulePositionUpdate();
    }
    applyContentAnimation(animation) {
        if (this.placement === 'none') {
            return Promise.resolve(true);
        }
        return new Promise((resolve) => {
            const contents = this.shadowRoot.querySelector('#contents');
            const doneHandler = (event) => {
                if (animation !== event.animationName)
                    return;
                contents.removeEventListener('animationend', doneHandler);
                contents.removeEventListener('animationcancel', doneHandler);
                this.animating = false;
                resolve(event.type === 'animationcancel');
            };
            contents.addEventListener('animationend', doneHandler);
            contents.addEventListener('animationcancel', doneHandler);
            contents.style.animationName = animation;
            this.animating = true;
        });
    }
    renderTheme(content) {
        const { color, scale, lang, theme } = this.theme;
        return _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_6__.html `
            <sp-theme
                theme=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_7__.ifDefined)(theme)}
                color=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_7__.ifDefined)(color)}
                scale=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_7__.ifDefined)(scale)}
                lang=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_7__.ifDefined)(lang)}
                part="theme"
            >
                ${content}
            </sp-theme>
        `;
    }
    render() {
        const content = _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_6__.html `
            <div id="contents">
                <slot @slotchange=${this.onSlotChange}></slot>
            </div>
        `;
        return this.hasTheme ? this.renderTheme(content) : content;
    }
    static create(details) {
        const overlay = new ActiveOverlay();
        if (details.content) {
            overlay.open(details);
        }
        return overlay;
    }
    async getUpdateComplete() {
        const actions = [
            super.getUpdateComplete(),
            this.stealOverlayContentPromise,
        ];
        if (this.childrenReady) {
            actions.push(this.childrenReady);
        }
        const [complete] = await Promise.all(actions);
        return complete;
    }
    disconnectedCallback() {
        document.removeEventListener('sp-update-overlays', this.updateOverlayPosition);
        window.removeEventListener('scroll', this.updateOverlayPosition);
        super.disconnectedCallback();
    }
}
(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([
    (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_9__.property)()
], ActiveOverlay.prototype, "_state", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([
    (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_9__.property)({ reflect: true, type: Boolean })
], ActiveOverlay.prototype, "animating", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([
    (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_9__.property)({ reflect: true })
], ActiveOverlay.prototype, "placement", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([
    (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_9__.property)({ attribute: false })
], ActiveOverlay.prototype, "theme", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_8__.__decorate)([
    (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_9__.property)({ attribute: false })
], ActiveOverlay.prototype, "receivesFocus", void 0);
//# sourceMappingURL=ActiveOverlay.js.map

/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/active-overlay.css.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/active-overlay.css.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/base */ "./node_modules/lit/index.js");
/*
Copyright 2022 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

const styles = _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.css `
@keyframes sp-overlay-fade-in{0%{opacity:0;transform:var(--sp-overlay-from)}to{opacity:1;transform:translate(0)}}@keyframes sp-overlay-fade-out{0%{opacity:1;transform:translate(0)}to{opacity:0;transform:var(--sp-overlay-from)}}:host{display:inline-block;left:-9999em;pointer-events:none;position:absolute;top:-9999em;z-index:1000}:host(:focus){outline:none}:host([placement=none]){height:100vh;height:-webkit-fill-available;height:fill-available;left:0;max-height:var(--swc-visual-viewport-height);position:fixed;top:0}#contents,sp-theme{height:100%}#contents{--swc-overlay-animation-distance:var(
--spectrum-picker-m-texticon-popover-offset-y,var(--spectrum-global-dimension-size-75)
);animation-duration:var(
--swc-test-duration,var(--spectrum-global-animation-duration-200,.16s)
);animation-timing-function:var(
--spectrum-global-animation-ease-out,ease-out
);box-sizing:border-box;display:inline-block;opacity:1;pointer-events:none;visibility:visible}:host([actual-placement*=top]) #contents{--sp-overlay-from:translateY(var(--spectrum-global-dimension-size-75));align-items:flex-end;display:inline-flex;padding-top:var(--swc-overlay-animation-distance)}:host([actual-placement*=right]) #contents{--sp-overlay-from:translateX(calc(var(--spectrum-global-dimension-size-75)*-1));padding-right:var(--swc-overlay-animation-distance)}:host([actual-placement*=bottom]) #contents{--sp-overlay-from:translateY(calc(var(--spectrum-global-dimension-size-75)*-1));padding-bottom:var(--swc-overlay-animation-distance)}:host([actual-placement*=left]) #contents{--sp-overlay-from:translateX(var(--spectrum-global-dimension-size-75));padding-left:var(--swc-overlay-animation-distance)}:host([animating]) ::slotted(*){pointer-events:none}:host(:not([animating])) ::slotted(*){pointer-events:auto}#contents ::slotted(*){position:relative}
`;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (styles);
//# sourceMappingURL=active-overlay.css.js.map

/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/overlay-stack.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/overlay-stack.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OverlayStack": () => (/* binding */ OverlayStack)
/* harmony export */ });
/* harmony import */ var _ActiveOverlay_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ActiveOverlay.js */ "./node_modules/@spectrum-web-components/overlay/src/ActiveOverlay.js");
/* harmony import */ var _overlay_timer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./overlay-timer.js */ "./node_modules/@spectrum-web-components/overlay/src/overlay-timer.js");
/* harmony import */ var _active_overlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../active-overlay.js */ "./node_modules/@spectrum-web-components/overlay/active-overlay.js");
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/



function isLeftClick(event) {
    return event.button === 0;
}
function hasModifier(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
class OverlayStack {
    constructor() {
        this.overlays = [];
        this.preventMouseRootClose = false;
        this.root = document.body;
        this.handlingResize = false;
        this.overlayTimer = new _overlay_timer_js__WEBPACK_IMPORTED_MODULE_1__.OverlayTimer();
        this.canTabTrap = true;
        this.trappingInited = false;
        this._eventsAreBound = false;
        this._bodyMarginsApplied = false;
        this.forwardContextmenuEvent = async (event) => {
            const topOverlay = this.overlays[this.overlays.length - 1];
            if (!this.trappingInited ||
                topOverlay.interaction !== 'modal' ||
                event.target !== this.overlayHolder) {
                return;
            }
            event.stopPropagation();
            event.preventDefault();
            await this.closeTopOverlay();
            let target = document.elementFromPoint(event.clientX, event.clientY);
            while (target === null || target === void 0 ? void 0 : target.shadowRoot) {
                const innerTarget = target.shadowRoot.elementFromPoint(event.clientX, event.clientY);
                if (!innerTarget || innerTarget === target) {
                    break;
                }
                target = innerTarget;
            }
            target === null || target === void 0 ? void 0 : target.dispatchEvent(new MouseEvent('contextmenu', event));
        };
        this.handleMouseCapture = (event) => {
            const topOverlay = this.topOverlay;
            if (!event.target ||
                !topOverlay ||
                !topOverlay.overlayContent ||
                hasModifier(event) ||
                !isLeftClick(event)) {
                this.preventMouseRootClose = true;
                return;
            }
            if (event.target instanceof Node) {
                const path = event.composedPath();
                if (path.indexOf(topOverlay.overlayContent) >= 0) {
                    this.preventMouseRootClose = true;
                    return;
                }
                this.preventMouseRootClose = false;
            }
        };
        /**
         * A "longpress" occurs before the "click" that creates it has occured.
         * In that way the first click will still be part of the "longpress" and
         * not part of closing the overlay.
         */
        this._doesNotCloseOnFirstClick = false;
        this.handleMouse = (event) => {
            if (this._doesNotCloseOnFirstClick) {
                this._doesNotCloseOnFirstClick = false;
                return;
            }
            if (this.preventMouseRootClose || event.defaultPrevented) {
                return;
            }
            this.closeTopOverlay(true);
        };
        this.handleKeyUp = (event) => {
            if (event.code === 'Escape') {
                this.closeTopOverlay();
            }
        };
        this.handleResize = () => {
            if (this.handlingResize)
                return;
            this.handlingResize = true;
            requestAnimationFrame(async () => {
                const promises = this.overlays.map((overlay) => overlay.updateOverlayPosition());
                await Promise.all(promises);
                this.handlingResize = false;
            });
        };
    }
    initTabTrapping() {
        if (this.trappingInited)
            return;
        this.trappingInited = true;
        /* c8 ignore next 4 */
        if (this.document.body.shadowRoot) {
            this.canTabTrap = false;
            return;
        }
        this.document.body.attachShadow({ mode: 'open' });
        /* c8 ignore next 3 */
        if (!this.document.body.shadowRoot) {
            return;
        }
        const root = this.document.body.shadowRoot;
        root.innerHTML = `
            <style>
            :host {
                position: relative;
            }
            #actual {
                position: relative;
                height: calc(100% - var(--swc-body-margins-block, 0px));
                z-index: 0;
                min-height: calc(100vh - var(--swc-body-margins-block, 0px));
            }
            #holder {
                display: none;
                align-items: center;
                justify-content: center;
                flex-flow: column;
                width: 100%;
                height: 100%;
                position: absolute;
                top: 0;
                left: 0;
            }
            [name="open"]::slotted(*) {
                pointer-events: all;
            }
            #actual[aria-hidden] + #holder {
                display: flex;
            }
            </style>
            <div id="actual"><slot></slot></div>
            <div id="holder"><slot name="open"></slot></div>
        `;
        this.tabTrapper = root.querySelector('#actual');
        this.overlayHolder = root.querySelector('#holder');
        this.tabTrapper.attachShadow({ mode: 'open' });
        if (this.tabTrapper.shadowRoot) {
            this.tabTrapper.shadowRoot.innerHTML = '<slot></slot>';
        }
        this.overlayHolder.addEventListener('contextmenu', this.forwardContextmenuEvent, true);
        requestAnimationFrame(() => {
            this.applyBodyMargins();
            const observer = new ResizeObserver(() => {
                this.applyBodyMargins();
            });
            observer.observe(document.body);
        });
    }
    applyBodyMargins() {
        const { marginLeft, marginRight, marginTop, marginBottom } = getComputedStyle(document.body);
        const allZero = parseFloat(marginLeft) === 0 &&
            parseFloat(marginRight) === 0 &&
            parseFloat(marginTop) === 0 &&
            parseFloat(marginBottom) === 0;
        if (allZero && !this._bodyMarginsApplied) {
            return;
        }
        this.tabTrapper.style.setProperty('--swc-body-margins-inline', `calc(${marginLeft} + ${marginRight})`);
        this.tabTrapper.style.setProperty('--swc-body-margins-block', `calc(${marginTop} + ${marginBottom})`);
        this._bodyMarginsApplied = !allZero;
    }
    startTabTrapping() {
        this.initTabTrapping();
        /* c8 ignore next 3 */
        if (!this.canTabTrap) {
            return;
        }
        this.tabTrapper.tabIndex = -1;
        this.tabTrapper.setAttribute('aria-hidden', 'true');
    }
    stopTabTrapping() {
        /* c8 ignore next 3 */
        if (!this.canTabTrap || !this.trappingInited) {
            return;
        }
        this.tabTrapper.removeAttribute('tabindex');
        this.tabTrapper.removeAttribute('aria-hidden');
    }
    get document() {
        return this.root.ownerDocument /* c8 ignore next */ || document;
    }
    get topOverlay() {
        return this.overlays.slice(-1)[0];
    }
    findOverlayForContent(overlayContent) {
        for (const item of this.overlays) {
            if (overlayContent === item.overlayContent) {
                return item;
            }
        }
        return undefined;
    }
    addEventListeners() {
        if (this._eventsAreBound)
            return;
        this._eventsAreBound = true;
        this.document.addEventListener('click', this.handleMouseCapture, true);
        this.document.addEventListener('click', this.handleMouse);
        this.document.addEventListener('keyup', this.handleKeyUp);
        window.addEventListener('resize', this.handleResize);
    }
    isClickOverlayActiveForTrigger(trigger) {
        return this.overlays.some((item) => trigger === item.trigger && item.interaction === 'click');
    }
    async openOverlay(details) {
        this.addEventListeners();
        if (this.findOverlayForContent(details.content)) {
            return false;
        }
        if (details.notImmediatelyClosable) {
            this._doesNotCloseOnFirstClick = true;
        }
        if (details.interaction === 'modal') {
            this.startTabTrapping();
        }
        const contentWithLifecycle = details.content;
        if (contentWithLifecycle.overlayWillOpenCallback) {
            const { trigger } = details;
            contentWithLifecycle.overlayWillOpenCallback({ trigger });
        }
        if (details.delayed) {
            const cancelledPromise = this.overlayTimer.openTimer(details.content);
            const promises = [cancelledPromise];
            if (details.abortPromise) {
                promises.push(details.abortPromise);
            }
            const cancelled = await Promise.race(promises);
            if (cancelled) {
                if (contentWithLifecycle.overlayOpenCancelledCallback) {
                    const { trigger } = details;
                    contentWithLifecycle.overlayOpenCancelledCallback({
                        trigger,
                    });
                }
                return cancelled;
            }
        }
        if (details.interaction === 'click') {
            this.closeAllHoverOverlays();
        }
        else if (details.interaction === 'hover' &&
            this.isClickOverlayActiveForTrigger(details.trigger)) {
            // Don't show a hover popover if the click popover is already active
            return true;
        }
        const activeOverlay = _ActiveOverlay_js__WEBPACK_IMPORTED_MODULE_2__.ActiveOverlay.create(details);
        if (this.overlays.length) {
            const topOverlay = this.overlays[this.overlays.length - 1];
            topOverlay.obscure(activeOverlay.interaction);
        }
        document.body.appendChild(activeOverlay);
        /**
         * The following work to make the new overlay the "top" of the stack
         * has to happen AFTER the current call stack completes in case there
         * is work there in to remove the previous "top" overlay.
         */
        return new Promise((res) => requestAnimationFrame(res)).then(async () => {
            this.overlays.push(activeOverlay);
            await activeOverlay.updateComplete;
            this.addOverlayEventListeners(activeOverlay);
            if (typeof contentWithLifecycle.open !== 'undefined') {
                contentWithLifecycle.open = true;
            }
            let cb = () => {
                return;
            };
            if (contentWithLifecycle.overlayOpenCallback) {
                const { trigger } = activeOverlay;
                const { overlayOpenCallback } = contentWithLifecycle;
                cb = async () => await overlayOpenCallback({ trigger });
            }
            await activeOverlay.openCallback(cb);
            return false;
        });
    }
    addOverlayEventListeners(activeOverlay) {
        activeOverlay.addEventListener('close', ((event) => {
            var _a;
            this.hideAndCloseOverlay(activeOverlay, true, // animated?
            !!((_a = event.detail) === null || _a === void 0 ? void 0 : _a.reason) // clickAway?
            );
        }));
        switch (activeOverlay.interaction) {
            case 'replace':
                this.addReplaceOverlayEventListeners(activeOverlay);
                break;
            case 'inline':
                this.addInlineOverlayEventListeners(activeOverlay);
                break;
        }
    }
    addReplaceOverlayEventListeners(activeOverlay) {
        activeOverlay.addEventListener('keydown', (event) => {
            const { code } = event;
            /* c8 ignore next */
            if (code !== 'Tab')
                return;
            event.stopPropagation();
            this.closeOverlay(activeOverlay.overlayContent);
            activeOverlay.tabbingAway = true;
            activeOverlay.trigger.focus();
            activeOverlay.trigger.dispatchEvent(new KeyboardEvent('keydown', event));
        });
    }
    addInlineOverlayEventListeners(activeOverlay) {
        activeOverlay.trigger.addEventListener('keydown', activeOverlay.handleInlineTriggerKeydown);
        activeOverlay.addEventListener('keydown', (event) => {
            const { code, shiftKey } = event;
            /* c8 ignore next */
            if (code !== 'Tab')
                return;
            activeOverlay.tabbingAway = true;
            if (shiftKey) {
                const returnFocusElement = document.createElement('span');
                returnFocusElement.tabIndex = -1;
                if (activeOverlay.trigger.hasAttribute('slot')) {
                    returnFocusElement.slot = activeOverlay.trigger.slot;
                }
                activeOverlay.trigger.insertAdjacentElement('afterend', returnFocusElement);
                returnFocusElement.focus();
                returnFocusElement.remove();
                return;
            }
            event.stopPropagation();
            const triggerWithLifecycle = activeOverlay.trigger;
            if (typeof triggerWithLifecycle.open !== 'undefined') {
                triggerWithLifecycle.open = false;
            }
            this.closeOverlay(activeOverlay.overlayContent);
            activeOverlay.trigger.focus();
        });
    }
    closeOverlay(content) {
        this.overlayTimer.close(content);
        requestAnimationFrame(() => {
            const overlay = this.findOverlayForContent(content);
            this.hideAndCloseOverlay(overlay);
        });
    }
    closeAllHoverOverlays() {
        for (const overlay of this.overlays) {
            if (overlay.interaction === 'hover') {
                this.hideAndCloseOverlay(overlay, false);
            }
        }
    }
    async manageFocusAfterCloseWhenOverlaysRemain() {
        const topOverlay = this.overlays[this.overlays.length - 1];
        topOverlay.feature();
        // Push focus in the the next remaining overlay as needed when a `type="modal"` overlay exists.
        if (topOverlay.interaction === 'modal' || topOverlay.hasModalRoot) {
            await topOverlay.focus();
        }
        else {
            this.stopTabTrapping();
        }
    }
    manageFocusAfterCloseWhenLastOverlay(overlay) {
        this.stopTabTrapping();
        const isModal = overlay.interaction === 'modal';
        const isReceivesFocus = overlay.receivesFocus === 'auto';
        const isReplace = overlay.interaction === 'replace';
        const isInline = overlay.interaction === 'inline';
        const isTabbingAwayFromInlineOrReplace = (isReplace || isInline) && !overlay.tabbingAway;
        overlay.tabbingAway = false;
        if (!isModal && !isReceivesFocus && !isTabbingAwayFromInlineOrReplace) {
            return;
        }
        // Manage post closure focus when needed.
        const overlayRoot = overlay.overlayContent.getRootNode();
        const overlayContentActiveElement = overlayRoot.activeElement;
        let triggerRoot;
        let triggerActiveElement;
        const contentContainsActiveElement = () => overlay.overlayContent.contains(overlayContentActiveElement);
        const triggerRootContainsActiveElement = () => {
            triggerRoot = overlay.trigger.getRootNode();
            triggerActiveElement = triggerRoot.activeElement;
            return triggerRoot.contains(triggerActiveElement);
        };
        const triggerHostIsActiveElement = () => triggerRoot.host && triggerRoot.host === triggerActiveElement;
        // Return focus to the trigger as long as the user hasn't actively focused
        // something outside of the current overlay interface; trigger, root, host.
        if (isModal ||
            contentContainsActiveElement() ||
            triggerRootContainsActiveElement() ||
            triggerHostIsActiveElement()) {
            overlay.trigger.focus();
        }
    }
    async hideAndCloseOverlay(overlay, animated, clickAway) {
        if (!overlay) {
            return;
        }
        const contentWithLifecycle = overlay.overlayContent;
        if (typeof contentWithLifecycle.overlayWillCloseCallback !== 'undefined') {
            const { trigger } = overlay;
            if (contentWithLifecycle.overlayWillCloseCallback({ trigger })) {
                return;
            }
        }
        await overlay.hide(animated);
        if (typeof contentWithLifecycle.open !== 'undefined') {
            contentWithLifecycle.open = false;
        }
        if (contentWithLifecycle.overlayCloseCallback) {
            const { trigger } = overlay;
            await contentWithLifecycle.overlayCloseCallback({ trigger });
        }
        if (overlay.state != 'dispose')
            return;
        const index = this.overlays.indexOf(overlay);
        if (index >= 0) {
            this.overlays.splice(index, 1);
        }
        if (this.overlays.length) {
            await this.manageFocusAfterCloseWhenOverlaysRemain();
        }
        else {
            this.manageFocusAfterCloseWhenLastOverlay(overlay);
        }
        overlay.remove();
        overlay.dispose();
        overlay.trigger.dispatchEvent(new CustomEvent('sp-closed', {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: {
                interaction: overlay.interaction,
                reason: clickAway ? 'external-click' : undefined,
            },
        }));
    }
    closeTopOverlay(clickAway) {
        return this.hideAndCloseOverlay(this.topOverlay, true, clickAway);
    }
}
//# sourceMappingURL=overlay-stack.js.map

/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/overlay-timer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/overlay-timer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OverlayTimer": () => (/* binding */ OverlayTimer)
/* harmony export */ });
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
const DEFAULT_WARMUP = 1000;
const DEFAULT_COOLDOWN = 1000;
/**
 * A timer to help with implementation of warnup/cooldown behavior as described here:
 * https://spectrum.adobe.com/page/tooltip/#Immediate-or-delayed-appearance
 */
class OverlayTimer {
    constructor(options = {}) {
        this.warmUpDelay = DEFAULT_WARMUP;
        this.coolDownDelay = DEFAULT_COOLDOWN;
        this.isWarm = false;
        this.timeout = 0;
        Object.assign(this, options);
    }
    async openTimer(component) {
        this.cancelCooldownTimer();
        if (!this.component || component !== this.component) {
            if (this.component) {
                this.close(this.component);
                this.cancelCooldownTimer();
            }
            this.component = component;
            if (this.isWarm) {
                return false;
            }
            this.promise = new Promise((resolve) => {
                this.resolve = resolve;
                this.timeout = window.setTimeout(() => {
                    if (this.resolve) {
                        this.resolve(false);
                        this.isWarm = true;
                    }
                }, this.warmUpDelay);
            });
            return this.promise;
        }
        else if (this.promise) {
            return this.promise;
        }
        else {
            // This should never happen
            throw new Error('Inconsistent state');
        }
    }
    close(component) {
        if (this.component && this.component === component) {
            this.resetCooldownTimer();
            if (this.timeout > 0) {
                clearTimeout(this.timeout);
                this.timeout = 0;
            }
            if (this.resolve) {
                this.resolve(true);
                delete this.resolve;
            }
            delete this.promise;
            delete this.component;
        }
    }
    resetCooldownTimer() {
        if (this.isWarm) {
            if (this.cooldownTimeout) {
                window.clearTimeout(this.cooldownTimeout);
            }
            this.cooldownTimeout = window.setTimeout(() => {
                this.isWarm = false;
                delete this.cooldownTimeout;
            }, this.coolDownDelay);
        }
    }
    cancelCooldownTimer() {
        if (this.cooldownTimeout) {
            window.clearTimeout(this.cooldownTimeout);
        }
        delete this.cooldownTimeout;
    }
}
//# sourceMappingURL=overlay-timer.js.map

/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/overlay.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/overlay.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Overlay": () => (/* binding */ Overlay)
/* harmony export */ });
/* harmony import */ var _overlay_stack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./overlay-stack.js */ "./node_modules/@spectrum-web-components/overlay/src/overlay-stack.js");
/*
Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/

/**
 * This class allows access to the overlay system which allows a client to
 * position an element in the overlay positioned relative to another node.
 */
class Overlay {
    /**
     *
     * @param owner the parent element we will use to position the overlay element
     * @param interaction the type of interaction that caused this overlay to be shown
     * @param overlayElement the item to display as an overlay
     */
    constructor(owner, interaction, overlayElement) {
        this.isOpen = false;
        this.owner = owner;
        this.overlayElement = overlayElement;
        this.interaction = interaction;
    }
    /**
     * Open an overlay
     *
     * @param owner the parent element we will use to position the overlay element
     * @param interaction the type of interaction that caused this overlay to be shown
     * @param overlayElement the item to display as an overlay
     * @param options display parameters
     * @param options.delayed if true delay opening of the overlay based on the global warmup/cooldown timer
     * @param options.offset distance to offset the overlay
     * @param options.placement side on which to position the overlay
     * @returns an Overlay object which can be used to close the overlay
     */
    static async open(owner, interaction, overlayElement, options) {
        const overlay = new Overlay(owner, interaction, overlayElement);
        await overlay.open(options);
        return () => {
            overlay.close();
        };
    }
    static update() {
        const overlayUpdateEvent = new CustomEvent('sp-update-overlays', {
            bubbles: true,
            composed: true,
            cancelable: true,
        });
        document.dispatchEvent(overlayUpdateEvent);
    }
    /**
     * Open an overlay
     *
     * @param options display parameters
     * @param options.delayed delay before opening the overlay
     * @param options.offset distance to offset the overlay
     * @param options.placement side on which to position the overlay
     * @returns a Promise that resolves to true if this operation was cancelled
     */
    async open({ abortPromise, delayed, offset = 0, placement = 'top', receivesFocus, notImmediatelyClosable, virtualTrigger, }) {
        /* c8 ignore next */
        if (this.isOpen)
            return true;
        if (delayed === undefined) {
            delayed = this.overlayElement.hasAttribute('delayed');
        }
        const queryThemeDetail = {
            color: undefined,
            scale: undefined,
            lang: undefined,
            theme: undefined,
        };
        const queryThemeEvent = new CustomEvent('sp-query-theme', {
            bubbles: true,
            composed: true,
            detail: queryThemeDetail,
            cancelable: true,
        });
        this.owner.dispatchEvent(queryThemeEvent);
        const overlayDetailQuery = {};
        const queryOverlayDetailEvent = new CustomEvent('sp-overlay-query', {
            bubbles: true,
            composed: true,
            detail: overlayDetailQuery,
            cancelable: true,
        });
        this.overlayElement.dispatchEvent(queryOverlayDetailEvent);
        await Overlay.overlayStack.openOverlay(Object.assign({ abortPromise, content: this.overlayElement, contentTip: overlayDetailQuery.overlayContentTipElement, delayed, offset: offset, placement: placement, trigger: this.owner, interaction: this.interaction, theme: queryThemeDetail, receivesFocus,
            notImmediatelyClosable,
            virtualTrigger }, overlayDetailQuery));
        this.isOpen = true;
        return true;
    }
    /**
     * Close the overlay if it is open
     */
    close() {
        Overlay.overlayStack.closeOverlay(this.overlayElement);
    }
}
Overlay.overlayStack = new _overlay_stack_js__WEBPACK_IMPORTED_MODULE_0__.OverlayStack();
/**
 * Announces that an overlay-based UI element has opened
 * @event sp-open
 * @type {object}
 * @property {TriggerInteractions} interaction type of interaction that triggered the opening
 */
/**
 * Announces that an overlay-based UI element has opened
 * @event sp-close
 * @type {object}
 * @property {TriggerInteractions} interaction type of interaction that triggered the closing
 */
//# sourceMappingURL=overlay.js.map

/***/ })

}])
//# sourceMappingURL=vendors-node_modules_spectrum-web-components_overlay_src_overlay_js.index.js.map