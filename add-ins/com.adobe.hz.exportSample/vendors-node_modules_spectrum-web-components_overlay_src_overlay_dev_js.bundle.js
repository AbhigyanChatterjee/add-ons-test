"use strict";
(self["webpackChunkexport_sample"] = self["webpackChunkexport_sample"] || []).push([["vendors-node_modules_spectrum-web-components_overlay_src_overlay_dev_js"],{

/***/ "./node_modules/@spectrum-web-components/overlay/active-overlay.dev.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/active-overlay.dev.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_ActiveOverlay_dev_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/ActiveOverlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/ActiveOverlay.dev.js");


customElements.define("active-overlay", _src_ActiveOverlay_dev_js__WEBPACK_IMPORTED_MODULE_0__.ActiveOverlay);
//# sourceMappingURL=active-overlay.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/ActiveOverlay.dev.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/ActiveOverlay.dev.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveOverlay": () => (/* binding */ ActiveOverlay)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/base */ "./node_modules/@spectrum-web-components/base/src/index.dev.js");
/* harmony import */ var _spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @spectrum-web-components/base/src/directives.js */ "./node_modules/@spectrum-web-components/base/src/directives.dev.js");
/* harmony import */ var _spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @spectrum-web-components/base/src/decorators.js */ "./node_modules/@spectrum-web-components/base/src/decorators.dev.js");
/* harmony import */ var _spectrum_web_components_shared_src_reparent_children_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @spectrum-web-components/shared/src/reparent-children.js */ "./node_modules/@spectrum-web-components/shared/src/reparent-children.dev.js");
/* harmony import */ var _spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @spectrum-web-components/shared/src/first-focusable-in.js */ "./node_modules/@spectrum-web-components/shared/src/first-focusable-in.dev.js");
/* harmony import */ var _active_overlay_css_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./active-overlay.css.js */ "./node_modules/@spectrum-web-components/overlay/src/active-overlay.css.js");
/* harmony import */ var _overlay_utils_dev_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./overlay-utils.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/overlay-utils.dev.js");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs");
/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @floating-ui/dom */ "./node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs");

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};








const stateMachine = {
  initial: "idle",
  states: {
    idle: {
      on: {
        active: "active"
      }
    },
    active: {
      on: {
        hiding: "hiding",
        idle: "idle"
      }
    },
    hiding: {
      on: {
        dispose: "dispose"
      }
    },
    dispose: {
      on: {
        disposed: "disposed"
      }
    },
    disposed: {
      on: {}
    }
  }
};
const stateTransition = (state, event) => {
  if (!state)
    return stateMachine.initial;
  if (!event)
    return state;
  return stateMachine.states[state].on[event] || state;
};
const getFallbackPlacements = (placement) => {
  var _a;
  const fallbacks = {
    left: ["right", "bottom", "top"],
    "left-start": ["right-start", "bottom", "top"],
    "left-end": ["right-end", "bottom", "top"],
    right: ["left", "bottom", "top"],
    "right-start": ["left-start", "bottom", "top"],
    "right-end": ["left-end", "bottom", "top"],
    top: ["bottom", "left", "right"],
    "top-start": ["bottom-start", "left", "right"],
    "top-end": ["bottom-end", "left", "right"],
    bottom: ["top", "left", "right"],
    "bottom-start": ["top-start", "left", "right"],
    "bottom-end": ["top-end", "left", "right"]
  };
  return (_a = fallbacks[placement]) != null ? _a : [placement];
};
const _ActiveOverlay = class extends _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.SpectrumElement {
  constructor() {
    super();
    this.contentAnimationPromise = Promise.resolve(true);
    this.resolveContentAnimationPromise = () => {
      return;
    };
    this._state = stateTransition();
    this.animating = false;
    this.theme = {};
    this.tabbingAway = false;
    this.offset = 6;
    this.skidding = 0;
    this.interaction = "hover";
    this.positionAnimationFrame = 0;
    this.willNotifyClosed = false;
    this.isConstrained = false;
    this.updateOverlayPosition = () => {
      if (this.interaction !== "modal" && this.cleanup) {
        this.dispatchEvent(new Event("close"));
        return;
      }
      this.setOverlayPosition();
    };
    this.resetOverlayPosition = () => {
      this.style.removeProperty("max-height");
      this.style.removeProperty("height");
      this.initialHeight = void 0;
      this.isConstrained = false;
      this.offsetHeight;
      this.setOverlayPosition();
    };
    this.setOverlayPosition = async () => {
      if (!this.placement || this.placement === "none") {
        return;
      }
      await (document.fonts ? document.fonts.ready : Promise.resolve());
      function roundByDPR(num) {
        const dpr = window.devicePixelRatio || 1;
        return Math.round(num * dpr) / dpr || -1e4;
      }
      const REQUIRED_DISTANCE_TO_EDGE = 8;
      const MIN_OVERLAY_HEIGHT = 100;
      const flipMiddleware = this.virtualTrigger ? (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_6__.flip)({
        padding: REQUIRED_DISTANCE_TO_EDGE,
        fallbackPlacements: getFallbackPlacements(this.placement)
      }) : (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_6__.flip)({
        padding: REQUIRED_DISTANCE_TO_EDGE
      });
      const middleware = [
        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_6__.offset)({
          mainAxis: this.offset,
          crossAxis: this.skidding
        }),
        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_6__.shift)({ padding: REQUIRED_DISTANCE_TO_EDGE }),
        flipMiddleware,
        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_6__.size)({
          padding: REQUIRED_DISTANCE_TO_EDGE,
          apply: ({
            availableWidth,
            availableHeight,
            rects: { floating }
          }) => {
            const maxHeight = Math.max(
              MIN_OVERLAY_HEIGHT,
              Math.floor(availableHeight)
            );
            const actualHeight = floating.height;
            this.initialHeight = !this.isConstrained && !this.virtualTrigger ? actualHeight : this.initialHeight || actualHeight;
            this.isConstrained = actualHeight < this.initialHeight || maxHeight <= actualHeight;
            const appliedHeight = this.isConstrained ? `${maxHeight}px` : "";
            Object.assign(this.style, {
              maxWidth: `${Math.floor(availableWidth)}px`,
              maxHeight: appliedHeight,
              height: appliedHeight
            });
          }
        })
      ];
      if (this.overlayContentTip) {
        middleware.push((0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_6__.arrow)({ element: this.overlayContentTip }));
      }
      const { x, y, placement, middlewareData } = await (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_7__.computePosition)(
        this.virtualTrigger || this.trigger,
        this,
        {
          placement: this.placement,
          middleware,
          strategy: "fixed"
        }
      );
      Object.assign(this.style, {
        top: "0px",
        left: "0px",
        transform: `translate(${roundByDPR(x)}px, ${roundByDPR(y)}px)`
      });
      if (placement !== this.getAttribute("actual-placement")) {
        this.setAttribute("actual-placement", placement);
        this.overlayContent.setAttribute("placement", placement);
      }
      if (this.overlayContentTip && middlewareData.arrow) {
        const { x: arrowX, y: arrowY } = middlewareData.arrow;
        Object.assign(this.overlayContentTip.style, {
          left: arrowX != null ? `${roundByDPR(arrowX)}px` : "",
          top: arrowY != null ? `${roundByDPR(arrowY)}px` : "",
          right: "",
          bottom: ""
        });
      }
    };
    this.handleInlineTriggerKeydown = (event) => {
      const { code, shiftKey } = event;
      if (code !== "Tab")
        return;
      if (shiftKey) {
        this.tabbingAway = true;
        this.dispatchEvent(new Event("close"));
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      this.focus();
    };
    this.stealOverlayContentPromise = Promise.resolve();
    this.stealOverlayContentPromise = new Promise(
      (res) => this.stealOverlayContentResolver = res
    );
  }
  get state() {
    return this._state;
  }
  set state(state) {
    const nextState = stateTransition(this.state, state);
    if (nextState === this.state) {
      return;
    }
    this._state = nextState;
    if (this.state === "active" || this.state === "hiding") {
      this.setAttribute("state", this.state);
    } else {
      this.removeAttribute("state");
    }
  }
  async focus() {
    const firstFocusable = (0,_spectrum_web_components_shared_src_first_focusable_in_js__WEBPACK_IMPORTED_MODULE_4__.firstFocusableIn)(this);
    if (firstFocusable) {
      if (firstFocusable.updateComplete) {
        await firstFocusable.updateComplete;
      }
      const activeElement = this.getRootNode().activeElement;
      if (activeElement === this || !this.contains(activeElement)) {
        firstFocusable.focus();
      }
    } else {
      super.focus();
    }
    this.removeAttribute("tabindex");
  }
  get hasTheme() {
    return !!this.theme.color || !!this.theme.scale || !!this.theme.lang;
  }
  static get styles() {
    return [_active_overlay_css_js__WEBPACK_IMPORTED_MODULE_8__["default"]];
  }
  get hasModalRoot() {
    return !!this._modalRoot;
  }
  feature() {
    if (!this.contains(document.activeElement)) {
      this.tabIndex = -1;
    }
    const parentOverlay = (0,_overlay_utils_dev_js__WEBPACK_IMPORTED_MODULE_5__.parentOverlayOf)(this.trigger);
    const parentIsModal = parentOverlay && parentOverlay.slot === "open";
    if (parentIsModal) {
      this._modalRoot = parentOverlay._modalRoot || parentOverlay;
    }
    if (this.interaction === "modal" || this._modalRoot) {
      this.slot = "open";
      if (this.interaction === "modal") {
        this.setAttribute("aria-modal", "true");
      }
      if (this._modalRoot) {
        parentOverlay == null ? void 0 : parentOverlay.feature();
      }
    }
  }
  obscure(nextOverlayInteraction) {
    if (this.slot && nextOverlayInteraction === "modal") {
      this.removeAttribute("slot");
      this.removeAttribute("aria-modal");
      if (this.interaction !== "modal") {
        const parentOverlay = (0,_overlay_utils_dev_js__WEBPACK_IMPORTED_MODULE_5__.parentOverlayOf)(this.trigger);
        this._modalRoot = parentOverlay == null ? void 0 : parentOverlay.obscure(
          nextOverlayInteraction
        );
        return this._modalRoot;
      }
      return this;
    }
    return void 0;
  }
  async willUpdate() {
    if (this.hasUpdated)
      return;
    if (!this.overlayContent || !this.trigger)
      return;
    this.stealOverlayContent(
      this.overlayContent
    );
    this.state = "active";
    this.feature();
    if (this.placement && this.placement !== "none") {
      await this.updateOverlayPosition();
      document.addEventListener(
        "sp-update-overlays",
        this.resetOverlayPosition
      );
    }
    if (this.placement && this.placement !== "none") {
      this.contentAnimationPromise = this.applyContentAnimation("sp-overlay-fade-in");
    }
  }
  async openCallback(lifecycleCallback) {
    await this.updateComplete;
    if (this.receivesFocus) {
      await this.focus();
    }
    await lifecycleCallback();
    this.trigger.dispatchEvent(
      new CustomEvent("sp-opened", {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail: {
          interaction: this.interaction
        }
      })
    );
  }
  open(openDetail) {
    this.extractDetail(openDetail);
  }
  extractDetail(detail) {
    this.overlayContent = detail.content;
    this.overlayContentTip = detail.contentTip;
    this.trigger = detail.trigger;
    this.virtualTrigger = detail.virtualTrigger;
    this.placement = detail.placement;
    this.offset = detail.offset;
    this.skidding = detail.skidding || 0;
    this.interaction = detail.interaction;
    this.theme = detail.theme;
    this.receivesFocus = detail.receivesFocus;
    this.root = detail.root;
  }
  dispose() {
    if (this.state !== "dispose")
      return;
    if (this.timeout) {
      clearTimeout(this.timeout);
      delete this.timeout;
    }
    this.trigger.removeEventListener(
      "keydown",
      this.handleInlineTriggerKeydown
    );
    this.returnOverlayContent();
    this.state = "disposed";
    if (this.willNotifyClosed) {
      this.overlayContent.dispatchEvent(new Event("sp-overlay-closed"));
      this.willNotifyClosed = false;
    }
    if (this.cleanup) {
      this.cleanup();
    }
  }
  stealOverlayContent(element) {
    this.originalPlacement = element.getAttribute("placement");
    this.restoreContent = (0,_spectrum_web_components_shared_src_reparent_children_js__WEBPACK_IMPORTED_MODULE_3__.reparentChildren)([element], this, {
      position: "beforeend",
      prepareCallback: (el) => {
        const slotName = el.slot;
        const placement = el.placement;
        el.removeAttribute("slot");
        return (el2) => {
          el2.slot = slotName;
          el2.placement = placement;
        };
      }
    });
    this.stealOverlayContentResolver();
  }
  returnOverlayContent() {
    if (!this.restoreContent)
      return;
    const [element] = this.restoreContent();
    this.restoreContent = void 0;
    this.willNotifyClosed = true;
    if (this.originalPlacement) {
      element.setAttribute("placement", this.originalPlacement);
      delete this.originalPlacement;
    }
  }
  async placeOverlay() {
    if (!this.placement || this.placement === "none") {
      return;
    }
    this.cleanup = (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_7__.autoUpdate)(
      this.virtualTrigger || this.trigger,
      this,
      this.updateOverlayPosition,
      {
        elementResize: false
      }
    );
  }
  async hide(animated = true) {
    if (this.state !== "active")
      return;
    this.state = "hiding";
    if (animated) {
      await this.applyContentAnimation("sp-overlay-fade-out");
    }
    this.state = "dispose";
  }
  schedulePositionUpdate() {
    cancelAnimationFrame(this.positionAnimationFrame);
    this.positionAnimationFrame = requestAnimationFrame(() => {
      if (this.cleanup) {
        this.updateOverlayPosition();
      } else {
        this.placeOverlay();
      }
    });
  }
  onSlotChange() {
    this.schedulePositionUpdate();
  }
  applyContentAnimation(animation) {
    if (this.placement === "none") {
      return Promise.resolve(true);
    }
    this.resolveContentAnimationPromise();
    return new Promise((resolve) => {
      this.resolveContentAnimationPromise = () => {
        resolve(false);
      };
      const contents = this.shadowRoot.querySelector(
        "#contents"
      );
      const doneHandler = (event) => {
        if (animation !== event.animationName)
          return;
        contents.removeEventListener("animationend", doneHandler);
        contents.removeEventListener("animationcancel", doneHandler);
        this.animating = false;
        resolve(event.type === "animationcancel");
      };
      contents.addEventListener("animationend", doneHandler);
      contents.addEventListener("animationcancel", doneHandler);
      contents.style.animationName = animation;
      this.animating = true;
    });
  }
  renderTheme(content) {
    const { color, scale, lang, theme } = this.theme;
    return _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.html`
            <sp-theme
                theme=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_1__.ifDefined)(theme)}
                color=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_1__.ifDefined)(color)}
                scale=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_1__.ifDefined)(scale)}
                lang=${(0,_spectrum_web_components_base_src_directives_js__WEBPACK_IMPORTED_MODULE_1__.ifDefined)(lang)}
                part="theme"
            >
                ${content}
            </sp-theme>
        `;
  }
  render() {
    const content = _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.html`
            <div id="contents">
                <slot @slotchange=${this.onSlotChange}></slot>
            </div>
        `;
    return this.hasTheme ? this.renderTheme(content) : content;
  }
  static create(details) {
    const overlay = new _ActiveOverlay();
    if (details.content) {
      overlay.open(details);
    }
    return overlay;
  }
  async getUpdateComplete() {
    const actions = [
      super.getUpdateComplete(),
      this.stealOverlayContentPromise
    ];
    actions.push(this.contentAnimationPromise);
    if (typeof this.overlayContent.updateComplete !== "undefined") {
      actions.push(
        this.overlayContent.updateComplete
      );
    }
    const [complete] = await Promise.all(actions);
    return complete;
  }
  disconnectedCallback() {
    document.removeEventListener(
      "sp-update-overlays",
      this.resetOverlayPosition
    );
    super.disconnectedCallback();
  }
};
let ActiveOverlay = _ActiveOverlay;
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_2__.property)()
], ActiveOverlay.prototype, "_state", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_2__.property)({ reflect: true, type: Boolean })
], ActiveOverlay.prototype, "animating", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_2__.property)({ reflect: true })
], ActiveOverlay.prototype, "placement", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_2__.property)({ attribute: false })
], ActiveOverlay.prototype, "theme", 2);
__decorateClass([
  (0,_spectrum_web_components_base_src_decorators_js__WEBPACK_IMPORTED_MODULE_2__.property)({ attribute: false })
], ActiveOverlay.prototype, "receivesFocus", 2);
//# sourceMappingURL=ActiveOverlay.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/active-overlay.css.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/active-overlay.css.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @spectrum-web-components/base */ "./node_modules/@spectrum-web-components/base/src/index.dev.js");
const e=_spectrum_web_components_base__WEBPACK_IMPORTED_MODULE_0__.css`
@keyframes sp-overlay-fade-in{0%{opacity:0;transform:var(--sp-overlay-from)}to{opacity:1;transform:translate(0)}}@keyframes sp-overlay-fade-out{0%{opacity:1;transform:translate(0)}to{opacity:0;transform:var(--sp-overlay-from)}}:host{display:inline-block;left:-9999em;max-height:100%;pointer-events:none;position:fixed;top:-9999em;z-index:1000}:host(:focus){outline:none}:host([placement=none]){height:100vh;height:100dvh;height:-webkit-fill-available;height:fill-available;left:0;position:fixed;top:0}#contents,sp-theme{height:100%}#contents{--swc-overlay-animation-distance:var(
--spectrum-picker-m-texticon-popover-offset-y,var(--spectrum-global-dimension-size-75)
);animation-duration:var(
--swc-test-duration,var(--spectrum-global-animation-duration-200,.16s)
);animation-timing-function:var(
--spectrum-global-animation-ease-out,ease-out
);box-sizing:border-box;display:inline-block;opacity:1;pointer-events:none;visibility:visible}:host([actual-placement*=top]) #contents{--sp-overlay-from:translateY(var(--spectrum-global-dimension-size-75));align-items:flex-end;display:inline-flex;padding-top:var(--swc-overlay-animation-distance)}:host([actual-placement*=right]) #contents{--sp-overlay-from:translateX(calc(var(--spectrum-global-dimension-size-75)*-1));padding-right:var(--swc-overlay-animation-distance)}:host([actual-placement*=bottom]) #contents{--sp-overlay-from:translateY(calc(var(--spectrum-global-dimension-size-75)*-1));padding-bottom:var(--swc-overlay-animation-distance)}:host([actual-placement*=left]) #contents{--sp-overlay-from:translateX(var(--spectrum-global-dimension-size-75));padding-left:var(--swc-overlay-animation-distance)}:host([animating]) ::slotted(*){pointer-events:none}:host(:not([animating])) ::slotted(*){pointer-events:auto}#contents ::slotted(*){position:relative}
`;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (e);
//# sourceMappingURL=active-overlay.css.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/overlay-stack.dev.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/overlay-stack.dev.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OverlayStack": () => (/* binding */ OverlayStack)
/* harmony export */ });
/* harmony import */ var _ActiveOverlay_dev_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActiveOverlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/ActiveOverlay.dev.js");
/* harmony import */ var _overlay_timer_dev_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./overlay-timer.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/overlay-timer.dev.js");
/* harmony import */ var _active_overlay_dev_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../active-overlay.dev.js */ "./node_modules/@spectrum-web-components/overlay/active-overlay.dev.js");
/* harmony import */ var _overlay_utils_dev_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./overlay-utils.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/overlay-utils.dev.js");
/* harmony import */ var _spectrum_web_components_shared_src_get_deep_element_from_point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @spectrum-web-components/shared/src/get-deep-element-from-point.js */ "./node_modules/@spectrum-web-components/shared/src/get-deep-element-from-point.dev.js");






function isLeftClick(event) {
  return event.button === 0;
}
function hasModifier(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function nextFrame() {
  return new Promise((res) => requestAnimationFrame(() => res()));
}
class OverlayStack {
  constructor() {
    this.overlays = [];
    this.preventMouseRootClose = false;
    this.root = document.body;
    this.handlingResize = false;
    this.overlayTimer = new _overlay_timer_dev_js__WEBPACK_IMPORTED_MODULE_1__.OverlayTimer();
    this.canTabTrap = true;
    this.trappingInited = false;
    this._eventsAreBound = false;
    this._bodyMarginsApplied = false;
    this.forwardContextmenuEvent = async (event) => {
      var _a;
      const topOverlay = this.overlays[this.overlays.length - 1];
      if (!this.trappingInited || topOverlay.interaction !== "modal" || event.target !== this.overlayHolder) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      await this.closeTopOverlay();
      (_a = (0,_spectrum_web_components_shared_src_get_deep_element_from_point_js__WEBPACK_IMPORTED_MODULE_4__.getDeepElementFromPoint)(event.clientX, event.clientY)) == null ? void 0 : _a.dispatchEvent(
        new MouseEvent("contextmenu", event)
      );
    };
    this.handleOverlayClose = (event) => {
      const { root } = event;
      if (!root)
        return;
      this.closeOverlaysForRoot(root);
    };
    this.handleMouseCapture = (event) => {
      const topOverlay = this.topOverlay;
      if (!event.target || !topOverlay || !topOverlay.overlayContent || hasModifier(event) || !isLeftClick(event)) {
        this.preventMouseRootClose = true;
        return;
      }
      if (event.target instanceof Node) {
        const path = event.composedPath();
        if (path.indexOf(topOverlay.overlayContent) >= 0) {
          this.preventMouseRootClose = true;
          return;
        }
        this.preventMouseRootClose = false;
      }
    };
    /**
     * A "longpress" occurs before the "click" that creates it has occured.
     * In that way the first click will still be part of the "longpress" and
     * not part of closing the overlay.
     */
    this._doesNotCloseOnFirstClick = false;
    this.handleMouse = (event) => {
      var _a;
      if (this._doesNotCloseOnFirstClick) {
        this._doesNotCloseOnFirstClick = false;
        return;
      }
      if (this.preventMouseRootClose || event.defaultPrevented) {
        return;
      }
      const overlaysToClose = [];
      let index = this.overlays.length;
      while (index && overlaysToClose.length === 0) {
        index -= 1;
        const overlay2 = this.overlays[index];
        const path = event.composedPath();
        const eventPathDictatesClosure = (!path.includes(overlay2.trigger) || overlay2.interaction !== "hover") && !path.includes(overlay2.overlayContent);
        if (eventPathDictatesClosure) {
          overlaysToClose.push(overlay2);
        }
      }
      let root = (_a = this.topOverlay) == null ? void 0 : _a.root;
      let overlay = (0,_overlay_utils_dev_js__WEBPACK_IMPORTED_MODULE_3__.parentOverlayOf)(root);
      while (root && overlay) {
        overlaysToClose.push(overlay);
        overlay = (0,_overlay_utils_dev_js__WEBPACK_IMPORTED_MODULE_3__.parentOverlayOf)(root);
        root = overlay == null ? void 0 : overlay.root;
      }
      if (overlay) {
        overlaysToClose.push(overlay);
      }
      overlaysToClose.forEach((overlay2) => this.hideAndCloseOverlay(overlay2));
    };
    this.handleKeydown = (event) => {
      if (event.code === "Escape") {
        this.closeTopOverlay();
      }
    };
    this.handleResize = () => {
      if (this.handlingResize)
        return;
      this.handlingResize = true;
      requestAnimationFrame(async () => {
        const promises = this.overlays.map(
          (overlay) => overlay.updateOverlayPosition()
        );
        await Promise.all(promises);
        this.handlingResize = false;
      });
    };
    this.initTabTrapping();
  }
  initTabTrapping() {
    if (document.readyState === "loading") {
      document.addEventListener(
        "readystatechange",
        () => {
          this.initTabTrapping();
        },
        { once: true }
      );
      return;
    }
    if (this.trappingInited)
      return;
    this.trappingInited = true;
    if (this.document.body.shadowRoot) {
      this.canTabTrap = false;
      return;
    }
    this.document.body.attachShadow({ mode: "open" });
    if (!this.document.body.shadowRoot) {
      return;
    }
    const root = this.document.body.shadowRoot;
    root.innerHTML = `
            <style>
            :host {
                position: relative;
            }
            #actual {
                position: relative;
                height: calc(100% - var(--swc-body-margins-block, 0px));
                z-index: 0;
                min-height: calc(100vh - var(--swc-body-margins-block, 0px));
            }
            #holder {
                display: none;
                align-items: center;
                justify-content: center;
                flex-flow: column;
                width: 100%;
                height: 100%;
                position: absolute;
                top: 0;
                left: 0;
            }
            [name="open"]::slotted(*) {
                pointer-events: all;
            }
            #actual[aria-hidden] + #holder {
                display: flex;
            }
            </style>
            <div id="actual"><slot></slot></div>
            <div id="holder"><slot name="open"></slot></div>
        `;
    this.tabTrapper = root.querySelector("#actual");
    this.overlayHolder = root.querySelector("#holder");
    this.tabTrapper.attachShadow({ mode: "open" });
    if (this.tabTrapper.shadowRoot) {
      this.tabTrapper.shadowRoot.innerHTML = "<slot></slot>";
    }
    this.overlayHolder.addEventListener(
      "contextmenu",
      this.forwardContextmenuEvent,
      true
    );
    requestAnimationFrame(() => {
      this.applyBodyMargins();
      const observer = new ResizeObserver(() => {
        this.applyBodyMargins();
      });
      observer.observe(document.body);
    });
  }
  applyBodyMargins() {
    const { marginLeft, marginRight, marginTop, marginBottom } = getComputedStyle(document.body);
    const allZero = parseFloat(marginLeft) === 0 && parseFloat(marginRight) === 0 && parseFloat(marginTop) === 0 && parseFloat(marginBottom) === 0;
    if (allZero && !this._bodyMarginsApplied) {
      return;
    }
    this.tabTrapper.style.setProperty(
      "--swc-body-margins-inline",
      `calc(${marginLeft} + ${marginRight})`
    );
    this.tabTrapper.style.setProperty(
      "--swc-body-margins-block",
      `calc(${marginTop} + ${marginBottom})`
    );
    this._bodyMarginsApplied = !allZero;
  }
  startTabTrapping() {
    this.initTabTrapping();
    if (!this.canTabTrap) {
      return;
    }
    this.tabTrapper.tabIndex = -1;
    this.tabTrapper.setAttribute("aria-hidden", "true");
  }
  stopTabTrapping() {
    if (!this.canTabTrap || !this.trappingInited) {
      return;
    }
    this.tabTrapper.removeAttribute("tabindex");
    this.tabTrapper.removeAttribute("aria-hidden");
  }
  get document() {
    return this.root.ownerDocument || document;
  }
  get topOverlay() {
    return this.overlays.slice(-1)[0];
  }
  findOverlayForContent(overlayContent) {
    for (const item of this.overlays) {
      if (overlayContent === item.overlayContent) {
        return item;
      }
    }
    return void 0;
  }
  addEventListeners() {
    if (this._eventsAreBound)
      return;
    this._eventsAreBound = true;
    this.document.addEventListener("click", this.handleMouseCapture, true);
    this.document.addEventListener("click", this.handleMouse);
    this.document.addEventListener("keydown", this.handleKeydown);
    this.document.addEventListener(
      "sp-overlay-close",
      this.handleOverlayClose
    );
    window.addEventListener("resize", this.handleResize);
  }
  isClickOverlayActiveForTrigger(trigger) {
    return this.overlays.some(
      (item) => trigger === item.trigger && item.interaction === "click"
    );
  }
  async openOverlay(details) {
    this.addEventListeners();
    if (this.findOverlayForContent(details.content)) {
      return false;
    }
    if (details.notImmediatelyClosable) {
      this._doesNotCloseOnFirstClick = true;
    }
    if (details.interaction === "modal") {
      this.startTabTrapping();
    }
    const contentWithLifecycle = details.content;
    const { trigger } = details;
    if (contentWithLifecycle.overlayWillOpenCallback) {
      contentWithLifecycle.overlayWillOpenCallback({ trigger });
    }
    if (details.delayed) {
      const cancelledPromise = this.overlayTimer.openTimer(
        details.content
      );
      const promises = [cancelledPromise];
      if (details.abortPromise) {
        promises.push(details.abortPromise);
      }
      const cancelled = await Promise.race(promises);
      if (cancelled) {
        if (contentWithLifecycle.overlayOpenCancelledCallback) {
          contentWithLifecycle.overlayOpenCancelledCallback({
            trigger
          });
        }
        return cancelled;
      }
    }
    if (details.root) {
      this.closeOverlaysForRoot(details.root);
    }
    if (details.interaction === "click") {
      this.closeAllHoverOverlays();
    } else if (details.interaction === "hover" && this.isClickOverlayActiveForTrigger(details.trigger)) {
      return true;
    }
    const activeOverlay = _ActiveOverlay_dev_js__WEBPACK_IMPORTED_MODULE_0__.ActiveOverlay.create(details);
    if (this.overlays.length) {
      const topOverlay = this.overlays[this.overlays.length - 1];
      topOverlay.obscure(activeOverlay.interaction);
    }
    document.body.appendChild(activeOverlay);
    await nextFrame();
    this.overlays.push(activeOverlay);
    await activeOverlay.updateComplete;
    this.addOverlayEventListeners(activeOverlay);
    if (typeof contentWithLifecycle.open !== "undefined") {
      await nextFrame();
      contentWithLifecycle.open = true;
    }
    let cb = () => {
      return;
    };
    if (contentWithLifecycle.overlayOpenCallback) {
      const { trigger: trigger2 } = activeOverlay;
      const { overlayOpenCallback } = contentWithLifecycle;
      cb = async () => await overlayOpenCallback({ trigger: trigger2 });
    }
    await activeOverlay.openCallback(cb);
    return false;
  }
  addOverlayEventListeners(activeOverlay) {
    activeOverlay.addEventListener("close", () => {
      this.hideAndCloseOverlay(
        activeOverlay,
        true
        // animated?
      );
    });
    switch (activeOverlay.interaction) {
      case "replace":
        this.addReplaceOverlayEventListeners(activeOverlay);
        break;
      case "inline":
        this.addInlineOverlayEventListeners(activeOverlay);
        break;
    }
  }
  addReplaceOverlayEventListeners(activeOverlay) {
    activeOverlay.addEventListener("keydown", (event) => {
      const { code } = event;
      if (code !== "Tab")
        return;
      event.stopPropagation();
      this.closeOverlay(activeOverlay.overlayContent);
      activeOverlay.tabbingAway = true;
      activeOverlay.trigger.focus();
      activeOverlay.trigger.dispatchEvent(
        new KeyboardEvent("keydown", event)
      );
    });
  }
  addInlineOverlayEventListeners(activeOverlay) {
    activeOverlay.trigger.addEventListener(
      "keydown",
      activeOverlay.handleInlineTriggerKeydown
    );
    activeOverlay.addEventListener("keydown", (event) => {
      const { code, shiftKey } = event;
      if (code !== "Tab")
        return;
      activeOverlay.tabbingAway = true;
      if (shiftKey) {
        const returnFocusElement = document.createElement("span");
        returnFocusElement.tabIndex = -1;
        if (activeOverlay.trigger.hasAttribute("slot")) {
          returnFocusElement.slot = activeOverlay.trigger.slot;
        }
        activeOverlay.trigger.insertAdjacentElement(
          "afterend",
          returnFocusElement
        );
        returnFocusElement.focus();
        returnFocusElement.remove();
        return;
      }
      event.stopPropagation();
      const triggerWithLifecycle = activeOverlay.trigger;
      if (typeof triggerWithLifecycle.open !== "undefined") {
        triggerWithLifecycle.open = false;
      }
      this.closeOverlay(activeOverlay.overlayContent);
      activeOverlay.trigger.focus();
    });
  }
  closeOverlay(content) {
    this.overlayTimer.close(content);
    requestAnimationFrame(() => {
      const overlayFromContent = this.findOverlayForContent(content);
      const overlaysToClose = [overlayFromContent];
      overlaysToClose.push(
        ...(0,_overlay_utils_dev_js__WEBPACK_IMPORTED_MODULE_3__.findOverlaysRootedInOverlay)(
          overlayFromContent,
          this.overlays
        )
      );
      overlaysToClose.forEach(
        (overlay) => this.hideAndCloseOverlay(overlay)
      );
    });
  }
  closeAllHoverOverlays() {
    for (const overlay of this.overlays) {
      if (overlay.interaction === "hover") {
        this.hideAndCloseOverlay(overlay, false);
      }
    }
  }
  closeOverlaysForRoot(root) {
    const overlaysToClose = [];
    for (const overlay of this.overlays) {
      if (overlay.root && overlay.root === root) {
        overlaysToClose.push(overlay);
        overlaysToClose.push(
          ...(0,_overlay_utils_dev_js__WEBPACK_IMPORTED_MODULE_3__.findOverlaysRootedInOverlay)(overlay, this.overlays)
        );
      }
    }
    overlaysToClose.forEach(
      (overlay) => this.hideAndCloseOverlay(overlay, true, true)
    );
  }
  async manageFocusAfterCloseWhenOverlaysRemain(returnBeforeFocus, previousTrigger) {
    const topOverlay = this.overlays[this.overlays.length - 1];
    topOverlay.feature();
    if (topOverlay.interaction === "modal" || topOverlay.hasModalRoot) {
      if (returnBeforeFocus)
        return;
      await (previousTrigger || topOverlay).focus();
    } else {
      this.stopTabTrapping();
    }
  }
  manageFocusAfterCloseWhenLastOverlay(overlay) {
    this.stopTabTrapping();
    const isModal = overlay.interaction === "modal";
    const isReceivesFocus = overlay.receivesFocus === "auto";
    const isReplace = overlay.interaction === "replace";
    const isInline = overlay.interaction === "inline";
    const isTabbingAwayFromInlineOrReplace = (isReplace || isInline) && !overlay.tabbingAway;
    overlay.tabbingAway = false;
    if (!isModal && !isReceivesFocus && !isTabbingAwayFromInlineOrReplace) {
      return;
    }
    const overlayRoot = overlay.overlayContent.getRootNode();
    const overlayContentActiveElement = overlayRoot.activeElement;
    let triggerRoot;
    let triggerActiveElement;
    const contentContainsActiveElement = () => overlay.overlayContent.contains(overlayContentActiveElement);
    const triggerRootContainsActiveElement = () => {
      triggerRoot = overlay.trigger.getRootNode();
      triggerActiveElement = triggerRoot.activeElement;
      return triggerRoot.contains(triggerActiveElement);
    };
    const triggerHostIsActiveElement = () => triggerRoot.host && triggerRoot.host === triggerActiveElement;
    if (isModal || contentContainsActiveElement() || triggerRootContainsActiveElement() || triggerHostIsActiveElement()) {
      overlay.trigger.focus();
    }
  }
  async hideAndCloseOverlay(overlay, animated, returnBeforeFocus) {
    if (!overlay) {
      return;
    }
    const contentWithLifecycle = overlay.overlayContent;
    if (typeof contentWithLifecycle.overlayWillCloseCallback !== "undefined") {
      const { trigger } = overlay;
      if (contentWithLifecycle.overlayWillCloseCallback({ trigger })) {
        return;
      }
    }
    await overlay.hide(animated);
    if (typeof contentWithLifecycle.open !== "undefined") {
      contentWithLifecycle.open = false;
    }
    if (contentWithLifecycle.overlayCloseCallback) {
      const { trigger } = overlay;
      await contentWithLifecycle.overlayCloseCallback({ trigger });
    }
    if (overlay.state != "dispose")
      return;
    const index = this.overlays.indexOf(overlay);
    if (index >= 0) {
      this.overlays.splice(index, 1);
    }
    if (this.overlays.length) {
      await this.manageFocusAfterCloseWhenOverlaysRemain(
        returnBeforeFocus || overlay.interaction === "hover",
        overlay.trigger
      );
    } else {
      this.manageFocusAfterCloseWhenLastOverlay(overlay);
    }
    await overlay.updateComplete;
    overlay.remove();
    overlay.dispose();
    overlay.trigger.dispatchEvent(
      new CustomEvent("sp-closed", {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail: {
          interaction: overlay.interaction
        }
      })
    );
  }
  closeTopOverlay() {
    return this.hideAndCloseOverlay(this.topOverlay, true);
  }
}
//# sourceMappingURL=overlay-stack.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/overlay-timer.dev.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/overlay-timer.dev.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OverlayTimer": () => (/* binding */ OverlayTimer)
/* harmony export */ });

const DEFAULT_WARMUP = 1e3;
const DEFAULT_COOLDOWN = 1e3;
class OverlayTimer {
  constructor(options = {}) {
    this.warmUpDelay = DEFAULT_WARMUP;
    this.coolDownDelay = DEFAULT_COOLDOWN;
    this.isWarm = false;
    this.timeout = 0;
    Object.assign(this, options);
  }
  async openTimer(component) {
    this.cancelCooldownTimer();
    if (!this.component || component !== this.component) {
      if (this.component) {
        this.close(this.component);
        this.cancelCooldownTimer();
      }
      this.component = component;
      if (this.isWarm) {
        return false;
      }
      this.promise = new Promise((resolve) => {
        this.resolve = resolve;
        this.timeout = window.setTimeout(() => {
          if (this.resolve) {
            this.resolve(false);
            this.isWarm = true;
          }
        }, this.warmUpDelay);
      });
      return this.promise;
    } else if (this.promise) {
      return this.promise;
    } else {
      throw new Error("Inconsistent state");
    }
  }
  close(component) {
    if (this.component && this.component === component) {
      this.resetCooldownTimer();
      if (this.timeout > 0) {
        clearTimeout(this.timeout);
        this.timeout = 0;
      }
      if (this.resolve) {
        this.resolve(true);
        delete this.resolve;
      }
      delete this.promise;
      delete this.component;
    }
  }
  resetCooldownTimer() {
    if (this.isWarm) {
      if (this.cooldownTimeout) {
        window.clearTimeout(this.cooldownTimeout);
      }
      this.cooldownTimeout = window.setTimeout(() => {
        this.isWarm = false;
        delete this.cooldownTimeout;
      }, this.coolDownDelay);
    }
  }
  cancelCooldownTimer() {
    if (this.cooldownTimeout) {
      window.clearTimeout(this.cooldownTimeout);
    }
    delete this.cooldownTimeout;
  }
}
//# sourceMappingURL=overlay-timer.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/overlay-utils.dev.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/overlay-utils.dev.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "findOverlaysRootedInOverlay": () => (/* binding */ findOverlaysRootedInOverlay),
/* harmony export */   "parentOverlayOf": () => (/* binding */ parentOverlayOf)
/* harmony export */ });

const parentOverlayOf = (el) => {
  if (!el)
    return null;
  const closestOverlay = el.closest("active-overlay");
  if (closestOverlay) {
    return closestOverlay;
  }
  const rootNode = el.getRootNode();
  if (rootNode.host) {
    return parentOverlayOf(rootNode.host);
  }
  return null;
};
const findOverlaysRootedInOverlay = (rootOverlay, activeOverlays) => {
  const overlays = [];
  if (!rootOverlay)
    return [];
  for (const overlay of activeOverlays) {
    if (!overlay.root)
      continue;
    if (parentOverlayOf(overlay.root) === rootOverlay) {
      overlays.push(overlay);
      overlays.push(
        ...findOverlaysRootedInOverlay(overlay, activeOverlays)
      );
    }
  }
  return overlays;
};
//# sourceMappingURL=overlay-utils.dev.js.map


/***/ }),

/***/ "./node_modules/@spectrum-web-components/overlay/src/overlay.dev.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@spectrum-web-components/overlay/src/overlay.dev.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Overlay": () => (/* binding */ Overlay)
/* harmony export */ });
/* harmony import */ var _overlay_stack_dev_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./overlay-stack.dev.js */ "./node_modules/@spectrum-web-components/overlay/src/overlay-stack.dev.js");


const _Overlay = class {
  /**
   *
   * @param owner the parent element we will use to position the overlay element
   * @param interaction the type of interaction that caused this overlay to be shown
   * @param overlayElement the item to display as an overlay
   */
  constructor(owner, interaction, overlayElement) {
    this.isOpen = false;
    this.owner = owner;
    this.overlayElement = overlayElement;
    this.interaction = interaction;
  }
  /**
   * Open an overlay
   *
   * @param owner the parent element we will use to position the overlay element
   * @param interaction the type of interaction that caused this overlay to be shown
   * @param overlayElement the item to display as an overlay
   * @param options display parameters
   * @param options.delayed if true delay opening of the overlay based on the global warmup/cooldown timer
   * @param options.offset distance to offset the overlay
   * @param options.placement side on which to position the overlay
   * @returns an Overlay object which can be used to close the overlay
   */
  static async open(owner, interaction, overlayElement, options) {
    const overlay = new _Overlay(owner, interaction, overlayElement);
    if (true) {
      window.__swc.warn(
        void 0,
        "The Overlay API is currently being refactored and there are likely to be breaking changes, deprecations and/or removals in a future release. The SWC team wants feedback from direct Overlay API consumers like you - please share your thoughts on the future of overlays here:",
        "https://github.com/adobe/spectrum-web-components/discussions/2764",
        {
          type: "default",
          level: "deprecation"
        }
      );
    }
    await overlay.open(options);
    return () => {
      overlay.close();
    };
  }
  static update() {
    const overlayUpdateEvent = new CustomEvent("sp-update-overlays", {
      bubbles: true,
      composed: true,
      cancelable: true
    });
    document.dispatchEvent(overlayUpdateEvent);
  }
  /**
   * Open an overlay
   *
   * @param options display parameters
   * @param options.delayed delay before opening the overlay
   * @param options.offset distance to offset the overlay
   * @param options.placement side on which to position the overlay
   * @returns a Promise that resolves to true if this operation was cancelled
   */
  async open({
    abortPromise,
    delayed,
    offset = 0,
    placement = "top",
    receivesFocus,
    notImmediatelyClosable,
    virtualTrigger,
    root
  }) {
    if (this.isOpen)
      return true;
    if (delayed === void 0) {
      delayed = this.overlayElement.hasAttribute("delayed");
    }
    const queryThemeDetail = {
      color: void 0,
      scale: void 0,
      lang: void 0,
      theme: void 0
    };
    const queryThemeEvent = new CustomEvent("sp-query-theme", {
      bubbles: true,
      composed: true,
      detail: queryThemeDetail,
      cancelable: true
    });
    this.owner.dispatchEvent(queryThemeEvent);
    const overlayDetailQuery = {};
    const queryOverlayDetailEvent = new CustomEvent("sp-overlay-query", {
      bubbles: true,
      composed: true,
      detail: overlayDetailQuery,
      cancelable: true
    });
    this.overlayElement.dispatchEvent(queryOverlayDetailEvent);
    await _Overlay.overlayStack.openOverlay({
      abortPromise,
      content: this.overlayElement,
      contentTip: overlayDetailQuery.overlayContentTipElement,
      delayed,
      offset,
      placement,
      trigger: this.owner,
      interaction: this.interaction,
      theme: queryThemeDetail,
      receivesFocus,
      root,
      notImmediatelyClosable,
      virtualTrigger,
      ...overlayDetailQuery
    });
    this.isOpen = true;
    return true;
  }
  /**
   * Close the overlay if it is open
   */
  close() {
    _Overlay.overlayStack.closeOverlay(this.overlayElement);
  }
};
let Overlay = _Overlay;
Overlay.overlayStack = new _overlay_stack_dev_js__WEBPACK_IMPORTED_MODULE_0__.OverlayStack();
//# sourceMappingURL=overlay.dev.js.map


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_spectrum-web-components_overlay_src_overlay_dev_js.bundle.js.map