{"version":3,"file":"vendors-node_modules_spectrum-web-components_overlay_src_overlay_dev_js.bundle.js","mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://export-sample/./node_modules/@spectrum-web-components/overlay/active-overlay.dev.js","webpack://export-sample/./node_modules/@spectrum-web-components/overlay/src/ActiveOverlay.dev.js","webpack://export-sample/./node_modules/@spectrum-web-components/overlay/src/active-overlay.css.js","webpack://export-sample/./node_modules/@spectrum-web-components/overlay/src/overlay-stack.dev.js","webpack://export-sample/./node_modules/@spectrum-web-components/overlay/src/overlay-timer.dev.js","webpack://export-sample/./node_modules/@spectrum-web-components/overlay/src/overlay-utils.dev.js","webpack://export-sample/./node_modules/@spectrum-web-components/overlay/src/overlay.dev.js"],"sourcesContent":["\"use strict\";\nimport { ActiveOverlay } from \"./src/ActiveOverlay.dev.js\";\ncustomElements.define(\"active-overlay\", ActiveOverlay);\n//# sourceMappingURL=active-overlay.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport { ifDefined } from \"@spectrum-web-components/base/src/directives.js\";\nimport { property } from \"@spectrum-web-components/base/src/decorators.js\";\nimport { reparentChildren } from \"@spectrum-web-components/shared/src/reparent-children.js\";\nimport { firstFocusableIn } from \"@spectrum-web-components/shared/src/first-focusable-in.js\";\nimport styles from \"./active-overlay.css.js\";\nimport { parentOverlayOf } from \"./overlay-utils.dev.js\";\nimport {\n  arrow,\n  autoUpdate,\n  computePosition,\n  flip,\n  offset,\n  shift,\n  size\n} from \"@floating-ui/dom\";\nconst stateMachine = {\n  initial: \"idle\",\n  states: {\n    idle: {\n      on: {\n        active: \"active\"\n      }\n    },\n    active: {\n      on: {\n        hiding: \"hiding\",\n        idle: \"idle\"\n      }\n    },\n    hiding: {\n      on: {\n        dispose: \"dispose\"\n      }\n    },\n    dispose: {\n      on: {\n        disposed: \"disposed\"\n      }\n    },\n    disposed: {\n      on: {}\n    }\n  }\n};\nconst stateTransition = (state, event) => {\n  if (!state)\n    return stateMachine.initial;\n  if (!event)\n    return state;\n  return stateMachine.states[state].on[event] || state;\n};\nconst getFallbackPlacements = (placement) => {\n  var _a;\n  const fallbacks = {\n    left: [\"right\", \"bottom\", \"top\"],\n    \"left-start\": [\"right-start\", \"bottom\", \"top\"],\n    \"left-end\": [\"right-end\", \"bottom\", \"top\"],\n    right: [\"left\", \"bottom\", \"top\"],\n    \"right-start\": [\"left-start\", \"bottom\", \"top\"],\n    \"right-end\": [\"left-end\", \"bottom\", \"top\"],\n    top: [\"bottom\", \"left\", \"right\"],\n    \"top-start\": [\"bottom-start\", \"left\", \"right\"],\n    \"top-end\": [\"bottom-end\", \"left\", \"right\"],\n    bottom: [\"top\", \"left\", \"right\"],\n    \"bottom-start\": [\"top-start\", \"left\", \"right\"],\n    \"bottom-end\": [\"top-end\", \"left\", \"right\"]\n  };\n  return (_a = fallbacks[placement]) != null ? _a : [placement];\n};\nconst _ActiveOverlay = class extends SpectrumElement {\n  constructor() {\n    super();\n    this.contentAnimationPromise = Promise.resolve(true);\n    this.resolveContentAnimationPromise = () => {\n      return;\n    };\n    this._state = stateTransition();\n    this.animating = false;\n    this.theme = {};\n    this.tabbingAway = false;\n    this.offset = 6;\n    this.skidding = 0;\n    this.interaction = \"hover\";\n    this.positionAnimationFrame = 0;\n    this.willNotifyClosed = false;\n    this.isConstrained = false;\n    this.updateOverlayPosition = () => {\n      if (this.interaction !== \"modal\" && this.cleanup) {\n        this.dispatchEvent(new Event(\"close\"));\n        return;\n      }\n      this.setOverlayPosition();\n    };\n    this.resetOverlayPosition = () => {\n      this.style.removeProperty(\"max-height\");\n      this.style.removeProperty(\"height\");\n      this.initialHeight = void 0;\n      this.isConstrained = false;\n      this.offsetHeight;\n      this.setOverlayPosition();\n    };\n    this.setOverlayPosition = async () => {\n      if (!this.placement || this.placement === \"none\") {\n        return;\n      }\n      await (document.fonts ? document.fonts.ready : Promise.resolve());\n      function roundByDPR(num) {\n        const dpr = window.devicePixelRatio || 1;\n        return Math.round(num * dpr) / dpr || -1e4;\n      }\n      const REQUIRED_DISTANCE_TO_EDGE = 8;\n      const MIN_OVERLAY_HEIGHT = 100;\n      const flipMiddleware = this.virtualTrigger ? flip({\n        padding: REQUIRED_DISTANCE_TO_EDGE,\n        fallbackPlacements: getFallbackPlacements(this.placement)\n      }) : flip({\n        padding: REQUIRED_DISTANCE_TO_EDGE\n      });\n      const middleware = [\n        offset({\n          mainAxis: this.offset,\n          crossAxis: this.skidding\n        }),\n        shift({ padding: REQUIRED_DISTANCE_TO_EDGE }),\n        flipMiddleware,\n        size({\n          padding: REQUIRED_DISTANCE_TO_EDGE,\n          apply: ({\n            availableWidth,\n            availableHeight,\n            rects: { floating }\n          }) => {\n            const maxHeight = Math.max(\n              MIN_OVERLAY_HEIGHT,\n              Math.floor(availableHeight)\n            );\n            const actualHeight = floating.height;\n            this.initialHeight = !this.isConstrained && !this.virtualTrigger ? actualHeight : this.initialHeight || actualHeight;\n            this.isConstrained = actualHeight < this.initialHeight || maxHeight <= actualHeight;\n            const appliedHeight = this.isConstrained ? `${maxHeight}px` : \"\";\n            Object.assign(this.style, {\n              maxWidth: `${Math.floor(availableWidth)}px`,\n              maxHeight: appliedHeight,\n              height: appliedHeight\n            });\n          }\n        })\n      ];\n      if (this.overlayContentTip) {\n        middleware.push(arrow({ element: this.overlayContentTip }));\n      }\n      const { x, y, placement, middlewareData } = await computePosition(\n        this.virtualTrigger || this.trigger,\n        this,\n        {\n          placement: this.placement,\n          middleware,\n          strategy: \"fixed\"\n        }\n      );\n      Object.assign(this.style, {\n        top: \"0px\",\n        left: \"0px\",\n        transform: `translate(${roundByDPR(x)}px, ${roundByDPR(y)}px)`\n      });\n      if (placement !== this.getAttribute(\"actual-placement\")) {\n        this.setAttribute(\"actual-placement\", placement);\n        this.overlayContent.setAttribute(\"placement\", placement);\n      }\n      if (this.overlayContentTip && middlewareData.arrow) {\n        const { x: arrowX, y: arrowY } = middlewareData.arrow;\n        Object.assign(this.overlayContentTip.style, {\n          left: arrowX != null ? `${roundByDPR(arrowX)}px` : \"\",\n          top: arrowY != null ? `${roundByDPR(arrowY)}px` : \"\",\n          right: \"\",\n          bottom: \"\"\n        });\n      }\n    };\n    this.handleInlineTriggerKeydown = (event) => {\n      const { code, shiftKey } = event;\n      if (code !== \"Tab\")\n        return;\n      if (shiftKey) {\n        this.tabbingAway = true;\n        this.dispatchEvent(new Event(\"close\"));\n        return;\n      }\n      event.stopPropagation();\n      event.preventDefault();\n      this.focus();\n    };\n    this.stealOverlayContentPromise = Promise.resolve();\n    this.stealOverlayContentPromise = new Promise(\n      (res) => this.stealOverlayContentResolver = res\n    );\n  }\n  get state() {\n    return this._state;\n  }\n  set state(state) {\n    const nextState = stateTransition(this.state, state);\n    if (nextState === this.state) {\n      return;\n    }\n    this._state = nextState;\n    if (this.state === \"active\" || this.state === \"hiding\") {\n      this.setAttribute(\"state\", this.state);\n    } else {\n      this.removeAttribute(\"state\");\n    }\n  }\n  async focus() {\n    const firstFocusable = firstFocusableIn(this);\n    if (firstFocusable) {\n      if (firstFocusable.updateComplete) {\n        await firstFocusable.updateComplete;\n      }\n      const activeElement = this.getRootNode().activeElement;\n      if (activeElement === this || !this.contains(activeElement)) {\n        firstFocusable.focus();\n      }\n    } else {\n      super.focus();\n    }\n    this.removeAttribute(\"tabindex\");\n  }\n  get hasTheme() {\n    return !!this.theme.color || !!this.theme.scale || !!this.theme.lang;\n  }\n  static get styles() {\n    return [styles];\n  }\n  get hasModalRoot() {\n    return !!this._modalRoot;\n  }\n  feature() {\n    if (!this.contains(document.activeElement)) {\n      this.tabIndex = -1;\n    }\n    const parentOverlay = parentOverlayOf(this.trigger);\n    const parentIsModal = parentOverlay && parentOverlay.slot === \"open\";\n    if (parentIsModal) {\n      this._modalRoot = parentOverlay._modalRoot || parentOverlay;\n    }\n    if (this.interaction === \"modal\" || this._modalRoot) {\n      this.slot = \"open\";\n      if (this.interaction === \"modal\") {\n        this.setAttribute(\"aria-modal\", \"true\");\n      }\n      if (this._modalRoot) {\n        parentOverlay == null ? void 0 : parentOverlay.feature();\n      }\n    }\n  }\n  obscure(nextOverlayInteraction) {\n    if (this.slot && nextOverlayInteraction === \"modal\") {\n      this.removeAttribute(\"slot\");\n      this.removeAttribute(\"aria-modal\");\n      if (this.interaction !== \"modal\") {\n        const parentOverlay = parentOverlayOf(this.trigger);\n        this._modalRoot = parentOverlay == null ? void 0 : parentOverlay.obscure(\n          nextOverlayInteraction\n        );\n        return this._modalRoot;\n      }\n      return this;\n    }\n    return void 0;\n  }\n  async willUpdate() {\n    if (this.hasUpdated)\n      return;\n    if (!this.overlayContent || !this.trigger)\n      return;\n    this.stealOverlayContent(\n      this.overlayContent\n    );\n    this.state = \"active\";\n    this.feature();\n    if (this.placement && this.placement !== \"none\") {\n      await this.updateOverlayPosition();\n      document.addEventListener(\n        \"sp-update-overlays\",\n        this.resetOverlayPosition\n      );\n    }\n    if (this.placement && this.placement !== \"none\") {\n      this.contentAnimationPromise = this.applyContentAnimation(\"sp-overlay-fade-in\");\n    }\n  }\n  async openCallback(lifecycleCallback) {\n    await this.updateComplete;\n    if (this.receivesFocus) {\n      await this.focus();\n    }\n    await lifecycleCallback();\n    this.trigger.dispatchEvent(\n      new CustomEvent(\"sp-opened\", {\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n        detail: {\n          interaction: this.interaction\n        }\n      })\n    );\n  }\n  open(openDetail) {\n    this.extractDetail(openDetail);\n  }\n  extractDetail(detail) {\n    this.overlayContent = detail.content;\n    this.overlayContentTip = detail.contentTip;\n    this.trigger = detail.trigger;\n    this.virtualTrigger = detail.virtualTrigger;\n    this.placement = detail.placement;\n    this.offset = detail.offset;\n    this.skidding = detail.skidding || 0;\n    this.interaction = detail.interaction;\n    this.theme = detail.theme;\n    this.receivesFocus = detail.receivesFocus;\n    this.root = detail.root;\n  }\n  dispose() {\n    if (this.state !== \"dispose\")\n      return;\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      delete this.timeout;\n    }\n    this.trigger.removeEventListener(\n      \"keydown\",\n      this.handleInlineTriggerKeydown\n    );\n    this.returnOverlayContent();\n    this.state = \"disposed\";\n    if (this.willNotifyClosed) {\n      this.overlayContent.dispatchEvent(new Event(\"sp-overlay-closed\"));\n      this.willNotifyClosed = false;\n    }\n    if (this.cleanup) {\n      this.cleanup();\n    }\n  }\n  stealOverlayContent(element) {\n    this.originalPlacement = element.getAttribute(\"placement\");\n    this.restoreContent = reparentChildren([element], this, {\n      position: \"beforeend\",\n      prepareCallback: (el) => {\n        const slotName = el.slot;\n        const placement = el.placement;\n        el.removeAttribute(\"slot\");\n        return (el2) => {\n          el2.slot = slotName;\n          el2.placement = placement;\n        };\n      }\n    });\n    this.stealOverlayContentResolver();\n  }\n  returnOverlayContent() {\n    if (!this.restoreContent)\n      return;\n    const [element] = this.restoreContent();\n    this.restoreContent = void 0;\n    this.willNotifyClosed = true;\n    if (this.originalPlacement) {\n      element.setAttribute(\"placement\", this.originalPlacement);\n      delete this.originalPlacement;\n    }\n  }\n  async placeOverlay() {\n    if (!this.placement || this.placement === \"none\") {\n      return;\n    }\n    this.cleanup = autoUpdate(\n      this.virtualTrigger || this.trigger,\n      this,\n      this.updateOverlayPosition,\n      {\n        elementResize: false\n      }\n    );\n  }\n  async hide(animated = true) {\n    if (this.state !== \"active\")\n      return;\n    this.state = \"hiding\";\n    if (animated) {\n      await this.applyContentAnimation(\"sp-overlay-fade-out\");\n    }\n    this.state = \"dispose\";\n  }\n  schedulePositionUpdate() {\n    cancelAnimationFrame(this.positionAnimationFrame);\n    this.positionAnimationFrame = requestAnimationFrame(() => {\n      if (this.cleanup) {\n        this.updateOverlayPosition();\n      } else {\n        this.placeOverlay();\n      }\n    });\n  }\n  onSlotChange() {\n    this.schedulePositionUpdate();\n  }\n  applyContentAnimation(animation) {\n    if (this.placement === \"none\") {\n      return Promise.resolve(true);\n    }\n    this.resolveContentAnimationPromise();\n    return new Promise((resolve) => {\n      this.resolveContentAnimationPromise = () => {\n        resolve(false);\n      };\n      const contents = this.shadowRoot.querySelector(\n        \"#contents\"\n      );\n      const doneHandler = (event) => {\n        if (animation !== event.animationName)\n          return;\n        contents.removeEventListener(\"animationend\", doneHandler);\n        contents.removeEventListener(\"animationcancel\", doneHandler);\n        this.animating = false;\n        resolve(event.type === \"animationcancel\");\n      };\n      contents.addEventListener(\"animationend\", doneHandler);\n      contents.addEventListener(\"animationcancel\", doneHandler);\n      contents.style.animationName = animation;\n      this.animating = true;\n    });\n  }\n  renderTheme(content) {\n    const { color, scale, lang, theme } = this.theme;\n    return html`\n            <sp-theme\n                theme=${ifDefined(theme)}\n                color=${ifDefined(color)}\n                scale=${ifDefined(scale)}\n                lang=${ifDefined(lang)}\n                part=\"theme\"\n            >\n                ${content}\n            </sp-theme>\n        `;\n  }\n  render() {\n    const content = html`\n            <div id=\"contents\">\n                <slot @slotchange=${this.onSlotChange}></slot>\n            </div>\n        `;\n    return this.hasTheme ? this.renderTheme(content) : content;\n  }\n  static create(details) {\n    const overlay = new _ActiveOverlay();\n    if (details.content) {\n      overlay.open(details);\n    }\n    return overlay;\n  }\n  async getUpdateComplete() {\n    const actions = [\n      super.getUpdateComplete(),\n      this.stealOverlayContentPromise\n    ];\n    actions.push(this.contentAnimationPromise);\n    if (typeof this.overlayContent.updateComplete !== \"undefined\") {\n      actions.push(\n        this.overlayContent.updateComplete\n      );\n    }\n    const [complete] = await Promise.all(actions);\n    return complete;\n  }\n  disconnectedCallback() {\n    document.removeEventListener(\n      \"sp-update-overlays\",\n      this.resetOverlayPosition\n    );\n    super.disconnectedCallback();\n  }\n};\nexport let ActiveOverlay = _ActiveOverlay;\n__decorateClass([\n  property()\n], ActiveOverlay.prototype, \"_state\", 2);\n__decorateClass([\n  property({ reflect: true, type: Boolean })\n], ActiveOverlay.prototype, \"animating\", 2);\n__decorateClass([\n  property({ reflect: true })\n], ActiveOverlay.prototype, \"placement\", 2);\n__decorateClass([\n  property({ attribute: false })\n], ActiveOverlay.prototype, \"theme\", 2);\n__decorateClass([\n  property({ attribute: false })\n], ActiveOverlay.prototype, \"receivesFocus\", 2);\n//# sourceMappingURL=ActiveOverlay.dev.js.map\n","\"use strict\";import{css as t}from\"@spectrum-web-components/base\";const e=t`\n@keyframes sp-overlay-fade-in{0%{opacity:0;transform:var(--sp-overlay-from)}to{opacity:1;transform:translate(0)}}@keyframes sp-overlay-fade-out{0%{opacity:1;transform:translate(0)}to{opacity:0;transform:var(--sp-overlay-from)}}:host{display:inline-block;left:-9999em;max-height:100%;pointer-events:none;position:fixed;top:-9999em;z-index:1000}:host(:focus){outline:none}:host([placement=none]){height:100vh;height:100dvh;height:-webkit-fill-available;height:fill-available;left:0;position:fixed;top:0}#contents,sp-theme{height:100%}#contents{--swc-overlay-animation-distance:var(\n--spectrum-picker-m-texticon-popover-offset-y,var(--spectrum-global-dimension-size-75)\n);animation-duration:var(\n--swc-test-duration,var(--spectrum-global-animation-duration-200,.16s)\n);animation-timing-function:var(\n--spectrum-global-animation-ease-out,ease-out\n);box-sizing:border-box;display:inline-block;opacity:1;pointer-events:none;visibility:visible}:host([actual-placement*=top]) #contents{--sp-overlay-from:translateY(var(--spectrum-global-dimension-size-75));align-items:flex-end;display:inline-flex;padding-top:var(--swc-overlay-animation-distance)}:host([actual-placement*=right]) #contents{--sp-overlay-from:translateX(calc(var(--spectrum-global-dimension-size-75)*-1));padding-right:var(--swc-overlay-animation-distance)}:host([actual-placement*=bottom]) #contents{--sp-overlay-from:translateY(calc(var(--spectrum-global-dimension-size-75)*-1));padding-bottom:var(--swc-overlay-animation-distance)}:host([actual-placement*=left]) #contents{--sp-overlay-from:translateX(var(--spectrum-global-dimension-size-75));padding-left:var(--swc-overlay-animation-distance)}:host([animating]) ::slotted(*){pointer-events:none}:host(:not([animating])) ::slotted(*){pointer-events:auto}#contents ::slotted(*){position:relative}\n`;export default e;\n//# sourceMappingURL=active-overlay.css.js.map\n","\"use strict\";\nimport { ActiveOverlay } from \"./ActiveOverlay.dev.js\";\nimport { OverlayTimer } from \"./overlay-timer.dev.js\";\nimport \"../active-overlay.dev.js\";\nimport {\n  findOverlaysRootedInOverlay,\n  parentOverlayOf\n} from \"./overlay-utils.dev.js\";\nimport { getDeepElementFromPoint } from \"@spectrum-web-components/shared/src/get-deep-element-from-point.js\";\nfunction isLeftClick(event) {\n  return event.button === 0;\n}\nfunction hasModifier(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction nextFrame() {\n  return new Promise((res) => requestAnimationFrame(() => res()));\n}\nexport class OverlayStack {\n  constructor() {\n    this.overlays = [];\n    this.preventMouseRootClose = false;\n    this.root = document.body;\n    this.handlingResize = false;\n    this.overlayTimer = new OverlayTimer();\n    this.canTabTrap = true;\n    this.trappingInited = false;\n    this._eventsAreBound = false;\n    this._bodyMarginsApplied = false;\n    this.forwardContextmenuEvent = async (event) => {\n      var _a;\n      const topOverlay = this.overlays[this.overlays.length - 1];\n      if (!this.trappingInited || topOverlay.interaction !== \"modal\" || event.target !== this.overlayHolder) {\n        return;\n      }\n      event.stopPropagation();\n      event.preventDefault();\n      await this.closeTopOverlay();\n      (_a = getDeepElementFromPoint(event.clientX, event.clientY)) == null ? void 0 : _a.dispatchEvent(\n        new MouseEvent(\"contextmenu\", event)\n      );\n    };\n    this.handleOverlayClose = (event) => {\n      const { root } = event;\n      if (!root)\n        return;\n      this.closeOverlaysForRoot(root);\n    };\n    this.handleMouseCapture = (event) => {\n      const topOverlay = this.topOverlay;\n      if (!event.target || !topOverlay || !topOverlay.overlayContent || hasModifier(event) || !isLeftClick(event)) {\n        this.preventMouseRootClose = true;\n        return;\n      }\n      if (event.target instanceof Node) {\n        const path = event.composedPath();\n        if (path.indexOf(topOverlay.overlayContent) >= 0) {\n          this.preventMouseRootClose = true;\n          return;\n        }\n        this.preventMouseRootClose = false;\n      }\n    };\n    /**\n     * A \"longpress\" occurs before the \"click\" that creates it has occured.\n     * In that way the first click will still be part of the \"longpress\" and\n     * not part of closing the overlay.\n     */\n    this._doesNotCloseOnFirstClick = false;\n    this.handleMouse = (event) => {\n      var _a;\n      if (this._doesNotCloseOnFirstClick) {\n        this._doesNotCloseOnFirstClick = false;\n        return;\n      }\n      if (this.preventMouseRootClose || event.defaultPrevented) {\n        return;\n      }\n      const overlaysToClose = [];\n      let index = this.overlays.length;\n      while (index && overlaysToClose.length === 0) {\n        index -= 1;\n        const overlay2 = this.overlays[index];\n        const path = event.composedPath();\n        const eventPathDictatesClosure = (!path.includes(overlay2.trigger) || overlay2.interaction !== \"hover\") && !path.includes(overlay2.overlayContent);\n        if (eventPathDictatesClosure) {\n          overlaysToClose.push(overlay2);\n        }\n      }\n      let root = (_a = this.topOverlay) == null ? void 0 : _a.root;\n      let overlay = parentOverlayOf(root);\n      while (root && overlay) {\n        overlaysToClose.push(overlay);\n        overlay = parentOverlayOf(root);\n        root = overlay == null ? void 0 : overlay.root;\n      }\n      if (overlay) {\n        overlaysToClose.push(overlay);\n      }\n      overlaysToClose.forEach((overlay2) => this.hideAndCloseOverlay(overlay2));\n    };\n    this.handleKeydown = (event) => {\n      if (event.code === \"Escape\") {\n        this.closeTopOverlay();\n      }\n    };\n    this.handleResize = () => {\n      if (this.handlingResize)\n        return;\n      this.handlingResize = true;\n      requestAnimationFrame(async () => {\n        const promises = this.overlays.map(\n          (overlay) => overlay.updateOverlayPosition()\n        );\n        await Promise.all(promises);\n        this.handlingResize = false;\n      });\n    };\n    this.initTabTrapping();\n  }\n  initTabTrapping() {\n    if (document.readyState === \"loading\") {\n      document.addEventListener(\n        \"readystatechange\",\n        () => {\n          this.initTabTrapping();\n        },\n        { once: true }\n      );\n      return;\n    }\n    if (this.trappingInited)\n      return;\n    this.trappingInited = true;\n    if (this.document.body.shadowRoot) {\n      this.canTabTrap = false;\n      return;\n    }\n    this.document.body.attachShadow({ mode: \"open\" });\n    if (!this.document.body.shadowRoot) {\n      return;\n    }\n    const root = this.document.body.shadowRoot;\n    root.innerHTML = `\n            <style>\n            :host {\n                position: relative;\n            }\n            #actual {\n                position: relative;\n                height: calc(100% - var(--swc-body-margins-block, 0px));\n                z-index: 0;\n                min-height: calc(100vh - var(--swc-body-margins-block, 0px));\n            }\n            #holder {\n                display: none;\n                align-items: center;\n                justify-content: center;\n                flex-flow: column;\n                width: 100%;\n                height: 100%;\n                position: absolute;\n                top: 0;\n                left: 0;\n            }\n            [name=\"open\"]::slotted(*) {\n                pointer-events: all;\n            }\n            #actual[aria-hidden] + #holder {\n                display: flex;\n            }\n            </style>\n            <div id=\"actual\"><slot></slot></div>\n            <div id=\"holder\"><slot name=\"open\"></slot></div>\n        `;\n    this.tabTrapper = root.querySelector(\"#actual\");\n    this.overlayHolder = root.querySelector(\"#holder\");\n    this.tabTrapper.attachShadow({ mode: \"open\" });\n    if (this.tabTrapper.shadowRoot) {\n      this.tabTrapper.shadowRoot.innerHTML = \"<slot></slot>\";\n    }\n    this.overlayHolder.addEventListener(\n      \"contextmenu\",\n      this.forwardContextmenuEvent,\n      true\n    );\n    requestAnimationFrame(() => {\n      this.applyBodyMargins();\n      const observer = new ResizeObserver(() => {\n        this.applyBodyMargins();\n      });\n      observer.observe(document.body);\n    });\n  }\n  applyBodyMargins() {\n    const { marginLeft, marginRight, marginTop, marginBottom } = getComputedStyle(document.body);\n    const allZero = parseFloat(marginLeft) === 0 && parseFloat(marginRight) === 0 && parseFloat(marginTop) === 0 && parseFloat(marginBottom) === 0;\n    if (allZero && !this._bodyMarginsApplied) {\n      return;\n    }\n    this.tabTrapper.style.setProperty(\n      \"--swc-body-margins-inline\",\n      `calc(${marginLeft} + ${marginRight})`\n    );\n    this.tabTrapper.style.setProperty(\n      \"--swc-body-margins-block\",\n      `calc(${marginTop} + ${marginBottom})`\n    );\n    this._bodyMarginsApplied = !allZero;\n  }\n  startTabTrapping() {\n    this.initTabTrapping();\n    if (!this.canTabTrap) {\n      return;\n    }\n    this.tabTrapper.tabIndex = -1;\n    this.tabTrapper.setAttribute(\"aria-hidden\", \"true\");\n  }\n  stopTabTrapping() {\n    if (!this.canTabTrap || !this.trappingInited) {\n      return;\n    }\n    this.tabTrapper.removeAttribute(\"tabindex\");\n    this.tabTrapper.removeAttribute(\"aria-hidden\");\n  }\n  get document() {\n    return this.root.ownerDocument || document;\n  }\n  get topOverlay() {\n    return this.overlays.slice(-1)[0];\n  }\n  findOverlayForContent(overlayContent) {\n    for (const item of this.overlays) {\n      if (overlayContent === item.overlayContent) {\n        return item;\n      }\n    }\n    return void 0;\n  }\n  addEventListeners() {\n    if (this._eventsAreBound)\n      return;\n    this._eventsAreBound = true;\n    this.document.addEventListener(\"click\", this.handleMouseCapture, true);\n    this.document.addEventListener(\"click\", this.handleMouse);\n    this.document.addEventListener(\"keydown\", this.handleKeydown);\n    this.document.addEventListener(\n      \"sp-overlay-close\",\n      this.handleOverlayClose\n    );\n    window.addEventListener(\"resize\", this.handleResize);\n  }\n  isClickOverlayActiveForTrigger(trigger) {\n    return this.overlays.some(\n      (item) => trigger === item.trigger && item.interaction === \"click\"\n    );\n  }\n  async openOverlay(details) {\n    this.addEventListeners();\n    if (this.findOverlayForContent(details.content)) {\n      return false;\n    }\n    if (details.notImmediatelyClosable) {\n      this._doesNotCloseOnFirstClick = true;\n    }\n    if (details.interaction === \"modal\") {\n      this.startTabTrapping();\n    }\n    const contentWithLifecycle = details.content;\n    const { trigger } = details;\n    if (contentWithLifecycle.overlayWillOpenCallback) {\n      contentWithLifecycle.overlayWillOpenCallback({ trigger });\n    }\n    if (details.delayed) {\n      const cancelledPromise = this.overlayTimer.openTimer(\n        details.content\n      );\n      const promises = [cancelledPromise];\n      if (details.abortPromise) {\n        promises.push(details.abortPromise);\n      }\n      const cancelled = await Promise.race(promises);\n      if (cancelled) {\n        if (contentWithLifecycle.overlayOpenCancelledCallback) {\n          contentWithLifecycle.overlayOpenCancelledCallback({\n            trigger\n          });\n        }\n        return cancelled;\n      }\n    }\n    if (details.root) {\n      this.closeOverlaysForRoot(details.root);\n    }\n    if (details.interaction === \"click\") {\n      this.closeAllHoverOverlays();\n    } else if (details.interaction === \"hover\" && this.isClickOverlayActiveForTrigger(details.trigger)) {\n      return true;\n    }\n    const activeOverlay = ActiveOverlay.create(details);\n    if (this.overlays.length) {\n      const topOverlay = this.overlays[this.overlays.length - 1];\n      topOverlay.obscure(activeOverlay.interaction);\n    }\n    document.body.appendChild(activeOverlay);\n    await nextFrame();\n    this.overlays.push(activeOverlay);\n    await activeOverlay.updateComplete;\n    this.addOverlayEventListeners(activeOverlay);\n    if (typeof contentWithLifecycle.open !== \"undefined\") {\n      await nextFrame();\n      contentWithLifecycle.open = true;\n    }\n    let cb = () => {\n      return;\n    };\n    if (contentWithLifecycle.overlayOpenCallback) {\n      const { trigger: trigger2 } = activeOverlay;\n      const { overlayOpenCallback } = contentWithLifecycle;\n      cb = async () => await overlayOpenCallback({ trigger: trigger2 });\n    }\n    await activeOverlay.openCallback(cb);\n    return false;\n  }\n  addOverlayEventListeners(activeOverlay) {\n    activeOverlay.addEventListener(\"close\", () => {\n      this.hideAndCloseOverlay(\n        activeOverlay,\n        true\n        // animated?\n      );\n    });\n    switch (activeOverlay.interaction) {\n      case \"replace\":\n        this.addReplaceOverlayEventListeners(activeOverlay);\n        break;\n      case \"inline\":\n        this.addInlineOverlayEventListeners(activeOverlay);\n        break;\n    }\n  }\n  addReplaceOverlayEventListeners(activeOverlay) {\n    activeOverlay.addEventListener(\"keydown\", (event) => {\n      const { code } = event;\n      if (code !== \"Tab\")\n        return;\n      event.stopPropagation();\n      this.closeOverlay(activeOverlay.overlayContent);\n      activeOverlay.tabbingAway = true;\n      activeOverlay.trigger.focus();\n      activeOverlay.trigger.dispatchEvent(\n        new KeyboardEvent(\"keydown\", event)\n      );\n    });\n  }\n  addInlineOverlayEventListeners(activeOverlay) {\n    activeOverlay.trigger.addEventListener(\n      \"keydown\",\n      activeOverlay.handleInlineTriggerKeydown\n    );\n    activeOverlay.addEventListener(\"keydown\", (event) => {\n      const { code, shiftKey } = event;\n      if (code !== \"Tab\")\n        return;\n      activeOverlay.tabbingAway = true;\n      if (shiftKey) {\n        const returnFocusElement = document.createElement(\"span\");\n        returnFocusElement.tabIndex = -1;\n        if (activeOverlay.trigger.hasAttribute(\"slot\")) {\n          returnFocusElement.slot = activeOverlay.trigger.slot;\n        }\n        activeOverlay.trigger.insertAdjacentElement(\n          \"afterend\",\n          returnFocusElement\n        );\n        returnFocusElement.focus();\n        returnFocusElement.remove();\n        return;\n      }\n      event.stopPropagation();\n      const triggerWithLifecycle = activeOverlay.trigger;\n      if (typeof triggerWithLifecycle.open !== \"undefined\") {\n        triggerWithLifecycle.open = false;\n      }\n      this.closeOverlay(activeOverlay.overlayContent);\n      activeOverlay.trigger.focus();\n    });\n  }\n  closeOverlay(content) {\n    this.overlayTimer.close(content);\n    requestAnimationFrame(() => {\n      const overlayFromContent = this.findOverlayForContent(content);\n      const overlaysToClose = [overlayFromContent];\n      overlaysToClose.push(\n        ...findOverlaysRootedInOverlay(\n          overlayFromContent,\n          this.overlays\n        )\n      );\n      overlaysToClose.forEach(\n        (overlay) => this.hideAndCloseOverlay(overlay)\n      );\n    });\n  }\n  closeAllHoverOverlays() {\n    for (const overlay of this.overlays) {\n      if (overlay.interaction === \"hover\") {\n        this.hideAndCloseOverlay(overlay, false);\n      }\n    }\n  }\n  closeOverlaysForRoot(root) {\n    const overlaysToClose = [];\n    for (const overlay of this.overlays) {\n      if (overlay.root && overlay.root === root) {\n        overlaysToClose.push(overlay);\n        overlaysToClose.push(\n          ...findOverlaysRootedInOverlay(overlay, this.overlays)\n        );\n      }\n    }\n    overlaysToClose.forEach(\n      (overlay) => this.hideAndCloseOverlay(overlay, true, true)\n    );\n  }\n  async manageFocusAfterCloseWhenOverlaysRemain(returnBeforeFocus, previousTrigger) {\n    const topOverlay = this.overlays[this.overlays.length - 1];\n    topOverlay.feature();\n    if (topOverlay.interaction === \"modal\" || topOverlay.hasModalRoot) {\n      if (returnBeforeFocus)\n        return;\n      await (previousTrigger || topOverlay).focus();\n    } else {\n      this.stopTabTrapping();\n    }\n  }\n  manageFocusAfterCloseWhenLastOverlay(overlay) {\n    this.stopTabTrapping();\n    const isModal = overlay.interaction === \"modal\";\n    const isReceivesFocus = overlay.receivesFocus === \"auto\";\n    const isReplace = overlay.interaction === \"replace\";\n    const isInline = overlay.interaction === \"inline\";\n    const isTabbingAwayFromInlineOrReplace = (isReplace || isInline) && !overlay.tabbingAway;\n    overlay.tabbingAway = false;\n    if (!isModal && !isReceivesFocus && !isTabbingAwayFromInlineOrReplace) {\n      return;\n    }\n    const overlayRoot = overlay.overlayContent.getRootNode();\n    const overlayContentActiveElement = overlayRoot.activeElement;\n    let triggerRoot;\n    let triggerActiveElement;\n    const contentContainsActiveElement = () => overlay.overlayContent.contains(overlayContentActiveElement);\n    const triggerRootContainsActiveElement = () => {\n      triggerRoot = overlay.trigger.getRootNode();\n      triggerActiveElement = triggerRoot.activeElement;\n      return triggerRoot.contains(triggerActiveElement);\n    };\n    const triggerHostIsActiveElement = () => triggerRoot.host && triggerRoot.host === triggerActiveElement;\n    if (isModal || contentContainsActiveElement() || triggerRootContainsActiveElement() || triggerHostIsActiveElement()) {\n      overlay.trigger.focus();\n    }\n  }\n  async hideAndCloseOverlay(overlay, animated, returnBeforeFocus) {\n    if (!overlay) {\n      return;\n    }\n    const contentWithLifecycle = overlay.overlayContent;\n    if (typeof contentWithLifecycle.overlayWillCloseCallback !== \"undefined\") {\n      const { trigger } = overlay;\n      if (contentWithLifecycle.overlayWillCloseCallback({ trigger })) {\n        return;\n      }\n    }\n    await overlay.hide(animated);\n    if (typeof contentWithLifecycle.open !== \"undefined\") {\n      contentWithLifecycle.open = false;\n    }\n    if (contentWithLifecycle.overlayCloseCallback) {\n      const { trigger } = overlay;\n      await contentWithLifecycle.overlayCloseCallback({ trigger });\n    }\n    if (overlay.state != \"dispose\")\n      return;\n    const index = this.overlays.indexOf(overlay);\n    if (index >= 0) {\n      this.overlays.splice(index, 1);\n    }\n    if (this.overlays.length) {\n      await this.manageFocusAfterCloseWhenOverlaysRemain(\n        returnBeforeFocus || overlay.interaction === \"hover\",\n        overlay.trigger\n      );\n    } else {\n      this.manageFocusAfterCloseWhenLastOverlay(overlay);\n    }\n    await overlay.updateComplete;\n    overlay.remove();\n    overlay.dispose();\n    overlay.trigger.dispatchEvent(\n      new CustomEvent(\"sp-closed\", {\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n        detail: {\n          interaction: overlay.interaction\n        }\n      })\n    );\n  }\n  closeTopOverlay() {\n    return this.hideAndCloseOverlay(this.topOverlay, true);\n  }\n}\n//# sourceMappingURL=overlay-stack.dev.js.map\n","\"use strict\";\nconst DEFAULT_WARMUP = 1e3;\nconst DEFAULT_COOLDOWN = 1e3;\nexport class OverlayTimer {\n  constructor(options = {}) {\n    this.warmUpDelay = DEFAULT_WARMUP;\n    this.coolDownDelay = DEFAULT_COOLDOWN;\n    this.isWarm = false;\n    this.timeout = 0;\n    Object.assign(this, options);\n  }\n  async openTimer(component) {\n    this.cancelCooldownTimer();\n    if (!this.component || component !== this.component) {\n      if (this.component) {\n        this.close(this.component);\n        this.cancelCooldownTimer();\n      }\n      this.component = component;\n      if (this.isWarm) {\n        return false;\n      }\n      this.promise = new Promise((resolve) => {\n        this.resolve = resolve;\n        this.timeout = window.setTimeout(() => {\n          if (this.resolve) {\n            this.resolve(false);\n            this.isWarm = true;\n          }\n        }, this.warmUpDelay);\n      });\n      return this.promise;\n    } else if (this.promise) {\n      return this.promise;\n    } else {\n      throw new Error(\"Inconsistent state\");\n    }\n  }\n  close(component) {\n    if (this.component && this.component === component) {\n      this.resetCooldownTimer();\n      if (this.timeout > 0) {\n        clearTimeout(this.timeout);\n        this.timeout = 0;\n      }\n      if (this.resolve) {\n        this.resolve(true);\n        delete this.resolve;\n      }\n      delete this.promise;\n      delete this.component;\n    }\n  }\n  resetCooldownTimer() {\n    if (this.isWarm) {\n      if (this.cooldownTimeout) {\n        window.clearTimeout(this.cooldownTimeout);\n      }\n      this.cooldownTimeout = window.setTimeout(() => {\n        this.isWarm = false;\n        delete this.cooldownTimeout;\n      }, this.coolDownDelay);\n    }\n  }\n  cancelCooldownTimer() {\n    if (this.cooldownTimeout) {\n      window.clearTimeout(this.cooldownTimeout);\n    }\n    delete this.cooldownTimeout;\n  }\n}\n//# sourceMappingURL=overlay-timer.dev.js.map\n","\"use strict\";\nexport const parentOverlayOf = (el) => {\n  if (!el)\n    return null;\n  const closestOverlay = el.closest(\"active-overlay\");\n  if (closestOverlay) {\n    return closestOverlay;\n  }\n  const rootNode = el.getRootNode();\n  if (rootNode.host) {\n    return parentOverlayOf(rootNode.host);\n  }\n  return null;\n};\nexport const findOverlaysRootedInOverlay = (rootOverlay, activeOverlays) => {\n  const overlays = [];\n  if (!rootOverlay)\n    return [];\n  for (const overlay of activeOverlays) {\n    if (!overlay.root)\n      continue;\n    if (parentOverlayOf(overlay.root) === rootOverlay) {\n      overlays.push(overlay);\n      overlays.push(\n        ...findOverlaysRootedInOverlay(overlay, activeOverlays)\n      );\n    }\n  }\n  return overlays;\n};\n//# sourceMappingURL=overlay-utils.dev.js.map\n","\"use strict\";\nimport { OverlayStack } from \"./overlay-stack.dev.js\";\nconst _Overlay = class {\n  /**\n   *\n   * @param owner the parent element we will use to position the overlay element\n   * @param interaction the type of interaction that caused this overlay to be shown\n   * @param overlayElement the item to display as an overlay\n   */\n  constructor(owner, interaction, overlayElement) {\n    this.isOpen = false;\n    this.owner = owner;\n    this.overlayElement = overlayElement;\n    this.interaction = interaction;\n  }\n  /**\n   * Open an overlay\n   *\n   * @param owner the parent element we will use to position the overlay element\n   * @param interaction the type of interaction that caused this overlay to be shown\n   * @param overlayElement the item to display as an overlay\n   * @param options display parameters\n   * @param options.delayed if true delay opening of the overlay based on the global warmup/cooldown timer\n   * @param options.offset distance to offset the overlay\n   * @param options.placement side on which to position the overlay\n   * @returns an Overlay object which can be used to close the overlay\n   */\n  static async open(owner, interaction, overlayElement, options) {\n    const overlay = new _Overlay(owner, interaction, overlayElement);\n    if (true) {\n      window.__swc.warn(\n        void 0,\n        \"The Overlay API is currently being refactored and there are likely to be breaking changes, deprecations and/or removals in a future release. The SWC team wants feedback from direct Overlay API consumers like you - please share your thoughts on the future of overlays here:\",\n        \"https://github.com/adobe/spectrum-web-components/discussions/2764\",\n        {\n          type: \"default\",\n          level: \"deprecation\"\n        }\n      );\n    }\n    await overlay.open(options);\n    return () => {\n      overlay.close();\n    };\n  }\n  static update() {\n    const overlayUpdateEvent = new CustomEvent(\"sp-update-overlays\", {\n      bubbles: true,\n      composed: true,\n      cancelable: true\n    });\n    document.dispatchEvent(overlayUpdateEvent);\n  }\n  /**\n   * Open an overlay\n   *\n   * @param options display parameters\n   * @param options.delayed delay before opening the overlay\n   * @param options.offset distance to offset the overlay\n   * @param options.placement side on which to position the overlay\n   * @returns a Promise that resolves to true if this operation was cancelled\n   */\n  async open({\n    abortPromise,\n    delayed,\n    offset = 0,\n    placement = \"top\",\n    receivesFocus,\n    notImmediatelyClosable,\n    virtualTrigger,\n    root\n  }) {\n    if (this.isOpen)\n      return true;\n    if (delayed === void 0) {\n      delayed = this.overlayElement.hasAttribute(\"delayed\");\n    }\n    const queryThemeDetail = {\n      color: void 0,\n      scale: void 0,\n      lang: void 0,\n      theme: void 0\n    };\n    const queryThemeEvent = new CustomEvent(\"sp-query-theme\", {\n      bubbles: true,\n      composed: true,\n      detail: queryThemeDetail,\n      cancelable: true\n    });\n    this.owner.dispatchEvent(queryThemeEvent);\n    const overlayDetailQuery = {};\n    const queryOverlayDetailEvent = new CustomEvent(\"sp-overlay-query\", {\n      bubbles: true,\n      composed: true,\n      detail: overlayDetailQuery,\n      cancelable: true\n    });\n    this.overlayElement.dispatchEvent(queryOverlayDetailEvent);\n    await _Overlay.overlayStack.openOverlay({\n      abortPromise,\n      content: this.overlayElement,\n      contentTip: overlayDetailQuery.overlayContentTipElement,\n      delayed,\n      offset,\n      placement,\n      trigger: this.owner,\n      interaction: this.interaction,\n      theme: queryThemeDetail,\n      receivesFocus,\n      root,\n      notImmediatelyClosable,\n      virtualTrigger,\n      ...overlayDetailQuery\n    });\n    this.isOpen = true;\n    return true;\n  }\n  /**\n   * Close the overlay if it is open\n   */\n  close() {\n    _Overlay.overlayStack.closeOverlay(this.overlayElement);\n  }\n};\nexport let Overlay = _Overlay;\nOverlay.overlayStack = new OverlayStack();\n//# sourceMappingURL=overlay.dev.js.map\n"],"names":[],"sourceRoot":""}